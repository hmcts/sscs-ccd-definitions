"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnsureEventually = void 0;
const core_1 = require("@serenity-js/core");
/**
 * The {@apilink Interaction|interaction} to `EnsureEventually`
 * verifies if the resolved value of the provided {@apilink Answerable}
 * meets the specified {@apilink Expectation} within the expected timeframe.
 *
 * If the expectation is not met by the time the timeout expires, the interaction throws an {@apilink AssertionError}.
 * `EnsureEventually` retries the evaluation if resolving the `actual` results in an {@apilink ListItemNotFoundError},
 * but rethrows any other errors.
 *
 * :::tip Use the factory method
 * Use the factory method {@apilink Ensure.eventually} to instantiate this interaction.
 * :::
 *
 * ## Basic usage with dynamic values
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { Ensure, equals } from '@serenity-js/assertions'
 * import { Text, PageElement, By } from '@serenity-js/web'
 *
 * await actorCalled('Erica').attemptsTo(
 *   Ensure.eventually(
 *     Text.of(PageElement.located(By.css('h1'))),
 *     equals('Learn Serenity/JS!')
 *   )
 * )
 * ```
 *
 * ## Composing expectations with `and`
 *
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { and, Ensure, startsWith, endsWith } from '@serenity-js/assertions'
 * import { Text, PageElement, By } from '@serenity-js/web'
 *
 * await actorCalled('Erica').attemptsTo(
 *   Ensure.eventually(
 *     Text.of(PageElement.located(By.css('h1'))),
 *     and(startsWith('Serenity'), endsWith('!'))
 *   )
 * )
 * ```
 *
 * ## Overriding the type of Error thrown upon assertion failure
 *
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { and, Ensure, startsWith, endsWith } from '@serenity-js/assertions'
 * import { Text, PageElement, By } from '@serenity-js/web'
 *
 * await actorCalled('Erica').attemptsTo(
 *   Ensure.eventually(
 *     Text.of(PageElement.located(By.css('h1'))),
 *     and(startsWith('Serenity'), endsWith('!'))
 *   ).otherwiseFailWith(LogicError, `Looks like we're not on the right page`)
 * )
 * ```
 *
 * @experimental
 *
 * @group Activities
 */
class EnsureEventually extends core_1.Interaction {
    /**
     * @param actual
     * @param expectation
     * @param location
     * @param timeout
     */
    constructor(actual, expectation, location, timeout) {
        super((0, core_1.d) `#actor ensures that ${actual} does eventually ${expectation}`, location);
        this.actual = actual;
        this.expectation = expectation;
        this.timeout = timeout;
    }
    /**
     * Override the default timeout set via {@apilink SerenityConfig.interactionTimeout}.
     *
     * @param timeout
     */
    timeoutAfter(timeout) {
        return new EnsureEventually(this.actual, this.expectation, this.instantiationLocation(), timeout);
    }
    /**
     * @inheritDoc
     */
    async performAs(actor) {
        await core_1.ScheduleWork.as(actor).repeatUntil(() => actor.answer(this.expectation.isMetFor(this.actual)), {
            exitCondition: outcome => outcome instanceof core_1.ExpectationMet,
            delayBetweenInvocations: (invocation) => invocation === 0
                ? core_1.Duration.ofMilliseconds(0) // perform the first evaluation straight away
                : core_1.Duration.ofMilliseconds(2 ** invocation * 100),
            timeout: this.timeout,
            errorHandler: (error, outcome) => {
                if (error instanceof core_1.ListItemNotFoundError) {
                    return; // ignore, lists might get populated later
                }
                if (error instanceof core_1.TimeoutExpiredError) {
                    const actualDescription = (0, core_1.d) `${this.actual}`;
                    const message = outcome ? `Expected ${actualDescription} to eventually ${outcome === null || outcome === void 0 ? void 0 : outcome.message}` : error.message;
                    throw core_1.RaiseErrors.as(actor).create(core_1.AssertionError, {
                        message,
                        expectation: outcome === null || outcome === void 0 ? void 0 : outcome.expectation,
                        diff: outcome && { expected: outcome === null || outcome === void 0 ? void 0 : outcome.expected, actual: outcome === null || outcome === void 0 ? void 0 : outcome.actual },
                        location: this.instantiationLocation(),
                        cause: error,
                    });
                }
                throw error;
            },
        });
    }
    /**
     * Overrides the default {@apilink AssertionError} thrown when
     * the actual value does not meet the expectation.
     *
     * @param typeOfRuntimeError
     *  A constructor function producing a subtype of {@apilink RuntimeError} to throw, e.g. {@apilink TestCompromisedError}
     *
     * @param message
     *  The message explaining the failure
     */
    otherwiseFailWith(typeOfRuntimeError, message) {
        const location = this.instantiationLocation();
        return core_1.Interaction.where(this.toString(), async (actor) => {
            try {
                await this.performAs(actor);
            }
            catch (error) {
                throw core_1.RaiseErrors.as(actor).create(typeOfRuntimeError, {
                    message: message !== null && message !== void 0 ? message : error.message,
                    location,
                    cause: error,
                });
            }
        });
    }
}
exports.EnsureEventually = EnsureEventually;
//# sourceMappingURL=EnsureEventually.js.map