"use strict";
const io_1 = require("@serenity-js/core/lib/io");
const model_1 = require("@serenity-js/core/lib/model");
const errors_1 = require("../../errors");
const gherkin_1 = require("./gherkin");
function get(object, property) {
    const getter = 'get' + property.charAt(0).toUpperCase() + property.slice(1);
    const value = object[getter]
        ? object[getter]()
        : object[property];
    return ({
        as: (type) => new type(value),
        value: () => value,
    });
}
function is(object, property) {
    const getter = 'is' + property.charAt(0).toUpperCase() + property.slice(1);
    return object[getter] ? object[getter]() : object[getter];
}
function findStepMatching(step, map) {
    const stepLine = get(step, 'line').value(), scenario = get(step, 'scenario').value(), path = get(scenario, 'uri').as(io_1.Path), scenarioLine = get(scenario, 'line').value();
    const matchedStep = map.get(gherkin_1.Scenario).onLine(scenarioLine).steps.find(s => s.location.line === stepLine);
    if (!matchedStep) {
        throw new Error(`No step was found in ${path} on line ${stepLine}. This looks like a bug.`);
    }
    return matchedStep;
}
function ambiguousStepsDetectedIn(result) {
    const ambiguousStepDefinitions = get(result, 'ambiguousStepDefinitions').value() || [];
    if (ambiguousStepDefinitions.length === 0) {
        return void 0;
    }
    return ambiguousStepDefinitions
        .map(step => `${get(step, 'pattern').value().toString()} - ${get(step, 'uri').value()}:${get(step, 'line').value()}`)
        .reduce((error, issue) => {
        error.message += `\n${issue}`;
        return error;
    }, new errors_1.AmbiguousStepDefinitionError('Multiple step definitions match:'));
}
function shouldIgnore(step) {
    return is(step, 'hidden') // cucumber 0-1
        || (step.constructor && step.constructor.name === 'Hook'); // cucumber 2
}
module.exports = function ({ serenity, notifier, resultMapper, loader, cache }) {
    return function () {
        this.registerHandler('BeforeFeatures', () => {
            notifier.testRunStarts();
        });
        this.registerHandler('BeforeFeature', function (feature, callback) {
            loader.load(get(feature, 'uri').as(io_1.Path))
                .then(_ => callback(), error => callback(error));
        });
        this.registerHandler('BeforeScenario', function (scenario) {
            const path = get(scenario, 'uri').as(io_1.Path), line = get(scenario, 'line').value(), lines = get(scenario, 'lines').value(), isOutline = lines.length === 2;
            const sceneId = serenity.assignNewSceneId(), map = cache.get(path);
            if (isOutline) {
                notifier.outlineDetected(sceneId, map.get(gherkin_1.Scenario).onLine(line), map.get(gherkin_1.ScenarioOutline).onLine(lines[1]), map.getFirst(gherkin_1.Feature));
            }
            notifier.scenarioStarts(sceneId, map.get(gherkin_1.Scenario).onLine(line), map.getFirst(gherkin_1.Feature));
        });
        this.registerHandler('BeforeStep', function (step) {
            if (shouldIgnore(step)) {
                return void 0;
            }
            const scenario = get(step, 'scenario').value(), path = get(scenario, 'uri').as(io_1.Path);
            notifier.stepStarts(findStepMatching(step, cache.get(path)));
        });
        this.registerHandler('StepResult', function (result) {
            const step = get(result, 'step').value(), scenario = get(step, 'scenario').value(), path = get(scenario, 'uri').as(io_1.Path);
            if (shouldIgnore(step)) {
                return void 0;
            }
            notifier.stepFinished(findStepMatching(step, cache.get(path)), resultMapper.outcomeFor(get(result, 'status').value(), get(result, 'failureException').value() || ambiguousStepsDetectedIn(result)));
        });
        this.registerHandler('ScenarioResult', function (result, callback) {
            const scenario = get(result, 'scenario').value(), path = get(scenario, 'uri').as(io_1.Path), line = get(scenario, 'line').value(), outcome = resultMapper.outcomeFor(get(result, 'status').value(), get(result, 'failureException').value());
            const map = cache.get(path);
            notifier.scenarioFinishes();
            serenity.waitForNextCue()
                .then(() => {
                notifier.scenarioFinished(map.get(gherkin_1.Scenario).onLine(line), map.getFirst(gherkin_1.Feature), outcome);
                callback();
            }, error => {
                notifier.scenarioFinished(map.get(gherkin_1.Scenario).onLine(line), map.getFirst(gherkin_1.Feature), outcome);
                callback(error);
            });
        });
        this.registerHandler('AfterFeatures', (features, callback) => {
            notifier.testRunFinishes();
            serenity.waitForNextCue()
                .then(() => {
                notifier.testRunFinished(new model_1.ExecutionSuccessful());
                return callback();
            }, error => {
                notifier.testRunFinished(new model_1.ExecutionFailedWithError(error));
                return callback(error);
            });
        });
    };
};
//# sourceMappingURL=cucumber-0.js.map