"use strict";
const messages_1 = require("@cucumber/messages");
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
const CucumberMessagesParser_1 = require("./parser/CucumberMessagesParser");
module.exports = function (serenity, moduleLoader) {
    var _a;
    const { Formatter, formatterHelpers } = moduleLoader.require('@cucumber/cucumber'), TestCaseHookDefinition = moduleLoader.require('@cucumber/cucumber/lib/models/test_case_hook_definition').default;
    return _a = class CucumberMessagesListener extends Formatter {
            constructor(options) {
                super(options);
                this.parser = new CucumberMessagesParser_1.CucumberMessagesParser(serenity, formatterHelpers, options, (step) => { var _a; return ((_a = step === null || step === void 0 ? void 0 : step.actionLocation) === null || _a === void 0 ? void 0 : _a.uri) !== CucumberMessagesListener.fakeInternalAfterHookUri; });
                this.addAfterHook(() => {
                    this.emit(new events_1.SceneFinishes(serenity.currentSceneId(), serenity.currentTime()));
                    return serenity.waitForNextCue();
                });
                options.eventBroadcaster.on('envelope', (envelope) => {
                    // this.log('> [cucumber] ' + JSON.stringify(envelope) + '\n');
                    switch (true) {
                        case !!envelope.testRunStarted:
                            return this.emit(new events_1.TestRunStarts(serenity.currentTime()));
                        case !!envelope.testCaseStarted:
                            return this.emit(this.parser.parseTestCaseStarted(envelope.testCaseStarted));
                        case !!envelope.testStepStarted:
                            return this.emit(this.parser.parseTestStepStarted(envelope.testStepStarted));
                        case !!envelope.testStepFinished:
                            return this.emit(this.parser.parseTestStepFinished(envelope.testStepFinished));
                        case !!envelope.testCaseFinished:
                            return this.emit(this.parser.parseTestCaseFinished(envelope.testCaseFinished));
                    }
                });
            }
            async finished() {
                this.emit(new events_1.TestRunFinishes(serenity.currentTime()));
                try {
                    await serenity.waitForNextCue();
                    this.emit(new events_1.TestRunFinished(new model_1.ExecutionSuccessful(), serenity.currentTime()));
                }
                catch (error) {
                    this.emit(new events_1.TestRunFinished(new model_1.ExecutionFailedWithError(error), serenity.currentTime()));
                    throw error;
                }
                finally {
                    await super.finished();
                }
            }
            addAfterHook(code) {
                this.supportCodeLibrary.afterTestCaseHookDefinitions.unshift(new TestCaseHookDefinition({
                    code,
                    id: messages_1.IdGenerator.uuid()(),
                    line: 0,
                    uri: CucumberMessagesListener.fakeInternalAfterHookUri,
                    options: {},
                }));
            }
            emit(events) {
                [].concat(events).forEach(event => serenity.announce(event));
            }
        },
        _a.fakeInternalAfterHookUri = '/internal/serenity-js/cucumber',
        _a;
};
//# sourceMappingURL=CucumberMessagesListener.js.map