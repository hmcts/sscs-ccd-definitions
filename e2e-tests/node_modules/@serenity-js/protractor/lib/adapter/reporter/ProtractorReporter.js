"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtractorReporter = void 0;
const events_1 = require("@serenity-js/core/lib/events");
const model_1 = require("@serenity-js/core/lib/model");
/**
 * @private
 */
class ProtractorReporter {
    constructor(runner, successThreshold = model_1.ExecutionSkipped, reported = { failedCount: 0, specResults: [] }, stage) {
        this.runner = runner;
        this.successThreshold = successThreshold;
        this.reported = reported;
        this.stage = stage;
        this.startTime = {};
    }
    assignedTo(stage) {
        return new ProtractorReporter(this.runner, this.successThreshold, this.reported, stage);
    }
    notifyOf(event) {
        if (event instanceof events_1.SceneStarts) {
            this.recordStart(event);
        }
        else if (event instanceof events_1.SceneFinishes) {
            this.afterEach();
        }
        else if (event instanceof events_1.SceneFinished && event.outcome.isWorseThan(this.successThreshold)) {
            this.recordFailure(event);
            this.runner.emit('testFail', {
                name: event.details.name.value,
                category: event.details.category.value,
            });
        }
        else if (event instanceof events_1.SceneFinished && !event.outcome.isWorseThan(this.successThreshold)) {
            this.recordSuccess(event);
            this.runner.emit('testPass', {
                name: event.details.name.value,
                category: event.details.category.value,
            });
        }
    }
    report() {
        return this.reported;
    }
    recordFailure(event) {
        const outcome = event.outcome;
        this.reported.failedCount++;
        this.reported.specResults.push({
            description: `${event.details.category.value} ${event.details.name.value}`,
            duration: event.timestamp.diff(this.startTime[event.details.toString()]).inMilliseconds(),
            assertions: [{
                    passed: false,
                    errorMsg: outcome.error.message,
                    stackTrace: outcome.error.stack,
                }],
        });
    }
    recordStart(event) {
        this.startTime[event.details.toString()] = event.timestamp;
    }
    recordSuccess(event) {
        this.reported.specResults.push({
            description: `${event.details.category.value} ${event.details.name.value}`,
            duration: event.timestamp.diff(this.startTime[event.details.toString()]).inMilliseconds(),
            assertions: [{
                    passed: true,
                }],
        });
    }
    async afterEach() {
        if (!this.runner.afterEach) {
            return;
        }
        const id = model_1.CorrelationId.create();
        this.stage.announce(new events_1.AsyncOperationAttempted(new model_1.Name(this.constructor.name), new model_1.Description(`Invoking ProtractorRunner.afterEach...`), id, this.stage.currentTime()));
        try {
            await this.runner.afterEach();
            this.stage.announce(new events_1.AsyncOperationCompleted(id, this.stage.currentTime()));
        }
        catch (error) {
            this.stage.announce(new events_1.AsyncOperationFailed(error, id, this.stage.currentTime()));
        }
    }
}
exports.ProtractorReporter = ProtractorReporter;
//# sourceMappingURL=ProtractorReporter.js.map