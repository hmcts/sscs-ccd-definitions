"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtractorPage = void 0;
const core_1 = require("@serenity-js/core");
const web_1 = require("@serenity-js/web");
const url_1 = require("url");
const promised_1 = require("../promised");
const locators_1 = require("./locators");
const ProtractorCookie_1 = require("./ProtractorCookie");
const ProtractorPageElement_1 = require("./ProtractorPageElement");
/**
 * Protractor-specific implementation of {@apilink Page}.
 *
 * @group Models
 */
class ProtractorPage extends web_1.Page {
    constructor(session, browser, modalDialogHandler, errorHandler, pageId) {
        super(session, new locators_1.ProtractorRootLocator(browser), modalDialogHandler, pageId);
        this.browser = browser;
        this.errorHandler = errorHandler;
    }
    locate(selector) {
        return new ProtractorPageElement_1.ProtractorPageElement(new locators_1.ProtractorLocator(this.rootLocator, selector, this.errorHandler));
    }
    locateAll(selector) {
        return new web_1.PageElements(new locators_1.ProtractorLocator(this.rootLocator, selector, this.errorHandler));
    }
    /**
     * If set to `false`, Protractor will not wait for Angular 1.x `$http` and `$timeout`
     * tasks to complete before interacting with the browser.
     *
     * This can be useful when:
     * - you need to switch to a non-Angular app during your tests, e.g. to sign in using an SSO gateway
     * - your app continuously polls an API with `$timeout`
     *
     * If you're not testing an Angular app, it's better to disable Angular synchronisation completely
     * in protractor configuration:
     *
     * ```js
     * // protractor.conf.js
     * exports.config = {
     *     onPrepare: function () {
     *         return browser.waitForAngularEnabled(false)
     *     },
     *
     *     // ... other config
     * }
     * ```
     *
     * @param enable
     */
    async enableAngularSynchronisation(enable) {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.waitForAngularEnabled(enable));
        });
    }
    async navigateTo(destination) {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.get(destination));
        });
    }
    async navigateBack() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.navigate().back());
        });
    }
    async navigateForward() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.navigate().forward());
        });
    }
    async reload() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.navigate().refresh());
        });
    }
    async sendKeys(keys) {
        function isModifier(maybeKey) {
            return web_1.Key.isKey(maybeKey) && maybeKey.isModifier;
        }
        function asCodePoint(maybeKey) {
            if (!web_1.Key.isKey(maybeKey)) {
                return maybeKey;
            }
            return maybeKey.utf16codePoint;
        }
        return await this.inContextOfThisPage(() => {
            // keyDown for any modifier keys and sendKeys otherwise
            const keyDownActions = keys.reduce((actions, key) => {
                return isModifier(key)
                    ? actions.keyDown(asCodePoint(key))
                    : actions.sendKeys(asCodePoint(key));
            }, this.browser.actions());
            // keyUp for any modifier keys, ignore for regular keys
            const keyUpActions = keys.reduce((actions, key) => {
                return isModifier(key)
                    ? actions.keyUp(asCodePoint(key))
                    : actions;
            }, keyDownActions);
            return (0, promised_1.promised)(keyUpActions.perform());
        });
    }
    async executeScript(script, ...args) {
        const innerArguments = [];
        for (const arg of args) {
            const innerArgument = arg instanceof ProtractorPageElement_1.ProtractorPageElement
                ? await arg.nativeElement()
                : arg;
            innerArguments.push(innerArgument);
        }
        const result = await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.executeScript(script, ...innerArguments));
        });
        this.lastScriptExecutionSummary = new LastScriptExecutionSummary(result);
        return result;
    }
    async executeAsyncScript(script, ...args) {
        const parameters = [];
        for (const arg of args) {
            const parameter = arg instanceof ProtractorPageElement_1.ProtractorPageElement
                ? await arg.nativeElement()
                : arg;
            parameters.push(parameter);
        }
        const result = await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.executeAsyncScript(script, ...parameters));
        });
        this.lastScriptExecutionSummary = new LastScriptExecutionSummary(result);
        return result;
    }
    lastScriptExecutionResult() {
        if (!this.lastScriptExecutionSummary) {
            throw new core_1.LogicError(`Make sure to execute a script before checking on the result`);
        }
        // Selenium 3 returns `null` when the script it executed returns `undefined`
        // so we're mapping the result back.
        return this.lastScriptExecutionSummary.result === null
            ? undefined
            : this.lastScriptExecutionSummary.result;
    }
    async takeScreenshot() {
        return await this.inContextOfThisPage(() => {
            try {
                return (0, promised_1.promised)(this.browser.takeScreenshot());
            }
            catch (error) {
                if (error.name && error.name === 'NoSuchSessionError') {
                    throw new web_1.BrowserWindowClosedError('Browser window is not available to take a screenshot', error);
                }
                throw error;
            }
        });
    }
    async cookie(name) {
        return new ProtractorCookie_1.ProtractorCookie(this.browser, name);
    }
    async setCookie(cookieData) {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.manage().addCookie({
                name: cookieData.name,
                value: cookieData.value,
                path: cookieData.path,
                domain: cookieData.domain,
                secure: cookieData.secure,
                httpOnly: cookieData.httpOnly,
                expiry: cookieData.expiry
                    ? cookieData.expiry.toSeconds()
                    : undefined,
            }));
        });
    }
    async deleteAllCookies() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.manage().deleteAllCookies());
        });
    }
    async title() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.getTitle());
        });
    }
    async name() {
        return await this.inContextOfThisPage(() => {
            return (0, promised_1.promised)(this.browser.executeScript('return window.name'));
        });
    }
    async url() {
        return await this.inContextOfThisPage(async () => {
            return new url_1.URL(await (0, promised_1.promised)(this.browser.getCurrentUrl()));
        });
    }
    async viewportSize() {
        return await this.inContextOfThisPage(async () => {
            const calculatedViewportSize = await (0, promised_1.promised)(this.browser.executeScript(`return {
                    width:  Math.max(document.documentElement.clientWidth,  window.innerWidth || 0),
                    height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                };`));
            if (calculatedViewportSize.width > 0 && calculatedViewportSize.height > 0) {
                return calculatedViewportSize;
            }
            // Chrome headless hard-codes window.innerWidth and window.innerHeight to 0
            return await (0, promised_1.promised)(this.browser.manage().window().getSize());
        });
    }
    async setViewportSize(size) {
        return await this.inContextOfThisPage(async () => {
            const desiredWindowSize = await (0, promised_1.promised)(this.browser.executeScript(`
                var currentViewportWidth  = Math.max(document.documentElement.clientWidth,  window.innerWidth || 0)
                var currentViewportHeight = Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
                
                return {
                    width:  Math.max(window.outerWidth  - currentViewportWidth  + ${size.width},  ${size.width}),
                    height: Math.max(window.outerHeight - currentViewportHeight + ${size.height}, ${size.height}),
                };
            `));
            return (0, promised_1.promised)(this.browser.manage().window().setSize(desiredWindowSize.width, desiredWindowSize.height));
        });
    }
    async close() {
        try {
            await this.inContextOfThisPage(async () => {
                await (0, promised_1.promised)(this.browser.close());
            });
        }
        catch (error) {
            if (error.name !== 'NoSuchWindowError') {
                throw error;
            }
        }
    }
    async closeOthers() {
        await this.session.closePagesOtherThan(this);
    }
    async isPresent() {
        const allPages = await this.session.allPages();
        for (const page of allPages) {
            if (page === this) {
                return true;
            }
        }
        return false;
    }
    async inContextOfThisPage(action) {
        let originalPage;
        try {
            originalPage = await this.session.currentPage();
            await this.session.changeCurrentPageTo(this);
            return await action();
        }
        catch (error) {
            return await this.errorHandler.executeIfHandled(error, action);
        }
        finally {
            if (originalPage) {
                await this.session.changeCurrentPageTo(originalPage);
            }
        }
    }
}
exports.ProtractorPage = ProtractorPage;
/**
 * @package
 */
class LastScriptExecutionSummary {
    constructor(result) {
        this.result = result;
    }
}
//# sourceMappingURL=ProtractorPage.js.map