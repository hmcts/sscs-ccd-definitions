/// <reference types="node" />
import { CorrelationId } from '@serenity-js/core/lib/model';
import { Cookie, CookieData, Key, ModalDialogHandler, Page, PageElement, PageElements, Selector } from '@serenity-js/web';
import { ElementFinder, ProtractorBrowser } from 'protractor';
import { URL } from 'url';
import { ProtractorBrowsingSession } from './ProtractorBrowsingSession';
import { ProtractorErrorHandler } from './ProtractorErrorHandler';
/**
 * Protractor-specific implementation of {@apilink Page}.
 *
 * @group Models
 */
export declare class ProtractorPage extends Page<ElementFinder> {
    private readonly browser;
    private readonly errorHandler;
    /**
     * @private
     */
    private lastScriptExecutionSummary;
    constructor(session: ProtractorBrowsingSession, browser: ProtractorBrowser, modalDialogHandler: ModalDialogHandler, errorHandler: ProtractorErrorHandler, pageId: CorrelationId);
    locate(selector: Selector): PageElement<ElementFinder>;
    locateAll(selector: Selector): PageElements<ElementFinder>;
    /**
     * If set to `false`, Protractor will not wait for Angular 1.x `$http` and `$timeout`
     * tasks to complete before interacting with the browser.
     *
     * This can be useful when:
     * - you need to switch to a non-Angular app during your tests, e.g. to sign in using an SSO gateway
     * - your app continuously polls an API with `$timeout`
     *
     * If you're not testing an Angular app, it's better to disable Angular synchronisation completely
     * in protractor configuration:
     *
     * ```js
     * // protractor.conf.js
     * exports.config = {
     *     onPrepare: function () {
     *         return browser.waitForAngularEnabled(false)
     *     },
     *
     *     // ... other config
     * }
     * ```
     *
     * @param enable
     */
    enableAngularSynchronisation(enable: boolean): Promise<boolean>;
    navigateTo(destination: string): Promise<void>;
    navigateBack(): Promise<void>;
    navigateForward(): Promise<void>;
    reload(): Promise<void>;
    sendKeys(keys: (string | Key)[]): Promise<void>;
    executeScript<Result, InnerArguments extends any[]>(script: string | ((...parameters: InnerArguments) => Result), ...args: InnerArguments): Promise<Result>;
    executeAsyncScript<Result, Parameters extends any[]>(script: string | ((...args: [...parameters: Parameters, callback: (result: Result) => void]) => void), ...args: Parameters): Promise<Result>;
    lastScriptExecutionResult(): any;
    takeScreenshot(): Promise<string>;
    cookie(name: string): Promise<Cookie>;
    setCookie(cookieData: CookieData): Promise<void>;
    deleteAllCookies(): Promise<void>;
    title(): Promise<string>;
    name(): Promise<string>;
    url(): Promise<URL>;
    viewportSize(): Promise<{
        width: number;
        height: number;
    }>;
    setViewportSize(size: {
        width: number;
        height: number;
    }): Promise<void>;
    close(): Promise<void>;
    closeOthers(): Promise<void>;
    isPresent(): Promise<boolean>;
    private inContextOfThisPage;
}
//# sourceMappingURL=ProtractorPage.d.ts.map