"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProtractorLocator = void 0;
const core_1 = require("@serenity-js/core");
const web_1 = require("@serenity-js/web");
const protractor = __importStar(require("protractor"));
const unpromisedWebElement_1 = require("../../unpromisedWebElement");
const ProtractorPageElement_1 = require("../ProtractorPageElement");
/**
 * Protractor-specific implementation of {@apilink Locator}.
 *
 * @group Models
 */
class ProtractorLocator extends web_1.Locator {
    constructor(parent, selector, errorHandler) {
        super(parent, selector);
        this.errorHandler = errorHandler;
    }
    // todo: refactor; replace with a map and some more generic lookup mechanism
    nativeSelector() {
        if (this.selector instanceof web_1.ByCss) {
            return protractor.by.css(this.selector.value);
        }
        if (this.selector instanceof web_1.ByDeepCss) {
            if (!protractor.by.shadowDomCss) {
                throw new core_1.LogicError(`By.deepCss() requires query-selector-shadow-dom plugin, which Serenity/JS ProtractorFrameworkAdapter registers by default. If you're using Serenity/JS without ProtractorFrameworkAdapter, please register the plugin yourself.`);
            }
            return protractor.by.shadowDomCss(this.selector.value.replace('>>>', '').trim());
        }
        if (this.selector instanceof web_1.ByCssContainingText) {
            return protractor.by.cssContainingText(this.selector.value, this.selector.text);
        }
        if (this.selector instanceof web_1.ById) {
            return protractor.by.id(this.selector.value);
        }
        if (this.selector instanceof web_1.ByTagName) {
            return protractor.by.tagName(this.selector.value);
        }
        if (this.selector instanceof web_1.ByXPath) {
            return protractor.by.xpath(this.selector.value);
        }
        throw new core_1.LogicError((0, core_1.f) `${this.selector} is not supported by ${this.constructor.name}`);
    }
    async isPresent() {
        try {
            const element = await this.resolveNativeElement();
            return Boolean(element);
        }
        catch {
            return false;
        }
    }
    async nativeElement() {
        try {
            return await this.resolveNativeElement();
        }
        catch (error) {
            return await this.errorHandler.executeIfHandled(error, () => this.resolveNativeElement());
        }
    }
    async resolveNativeElement() {
        const parent = await this.parent.nativeElement();
        const result = await (0, unpromisedWebElement_1.unpromisedWebElement)(parent.element(this.nativeSelector()));
        // checks if the element can be interacted with; in particular, throws unexpected alert present if there is one
        await result.isPresent();
        return result;
    }
    async allNativeElements() {
        const parent = await this.parent.nativeElement();
        return parent.all(this.nativeSelector());
    }
    of(parent) {
        return new ProtractorLocator(parent, this.selector, this.errorHandler);
    }
    locate(child) {
        return new ProtractorLocator(this, child.selector, this.errorHandler);
    }
    element() {
        return new ProtractorPageElement_1.ProtractorPageElement(this);
    }
    async allElements() {
        const elements = await this.allNativeElements();
        return Promise.all(elements.map(childElement => new ProtractorPageElement_1.ProtractorPageElement(new ExistingElementLocator(this.parent, this.selector, this.errorHandler, (0, unpromisedWebElement_1.unpromisedWebElement)(childElement)))));
    }
}
exports.ProtractorLocator = ProtractorLocator;
/**
 * @private
 */
class ExistingElementLocator extends ProtractorLocator {
    constructor(parent, selector, errorHandler, existingNativeElement) {
        super(parent, selector, errorHandler);
        this.existingNativeElement = existingNativeElement;
    }
    async nativeElement() {
        return this.existingNativeElement;
    }
    async allNativeElements() {
        return [this.existingNativeElement];
    }
}
//# sourceMappingURL=ProtractorLocator.js.map