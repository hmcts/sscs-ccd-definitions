"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Path = void 0;
const filenamify_1 = __importDefault(require("filenamify"));
const tiny_types_1 = require("tiny-types");
const upath_1 = __importStar(require("upath"));
class Path extends tiny_types_1.TinyType {
    static fromJSON(v) {
        return new Path(v);
    }
    static fromURI(uri) {
        // inspired by https://github.com/TooTallNate/file-uri-to-path
        if (typeof uri !== 'string' ||
            uri.length <= 7 ||
            uri.slice(0, 7) !== 'file://') {
            throw new TypeError(`A Path can be created only from URIs that start with 'file://'. Received: ${uri}`);
        }
        const rest = decodeURI(uri.slice(7));
        const firstSlash = rest.indexOf('/');
        let host = rest.slice(0, Math.max(0, firstSlash));
        // 2.  Scheme Definition
        // As a special case, <host> can be the string "localhost" or the empty
        // string; this is interpreted as "the machine from which the URL is being interpreted".
        if (host === 'localhost') {
            host = '';
        }
        if (host) {
            host = upath_1.sep + upath_1.sep + host;
        }
        let path = rest.slice(Math.max(0, firstSlash + 1));
        // Drives, drive letters, mount points, file system root
        //
        // Drive letters are mapped into the top of a file URI in various ways, depending on the implementation;
        // some applications substitute vertical bar ("|") for the colon after the drive letter,
        // yielding "file:///c|/tmp/test.txt".
        // In some cases, the colon is left unchanged, as in "file:///c:/tmp/test.txt".
        // In other cases, the colon is simply omitted, as in "file:///c/tmp/test.txt".
        path = path.replace(/^(.+)\|/, '$1:');
        // for Windows, we need to invert the path separators from what a URI uses
        if (upath_1.sep === '\\') {
            throw new Error('that used?');
            // path = path.replace(/\//g, '\\');
        }
        if (!(/^.+:/.test(path))) {
            // unix path, because there's no Windows drive at the beginning
            path = upath_1.sep + path;
        }
        return new Path(host + path);
    }
    static from(...segments) {
        return new Path(upath_1.default.joinSafe(...segments));
    }
    static fromSanitisedString(value) {
        const normalised = upath_1.default.normalize(value).replace(/["'/:\\]/gi, ''), extension = upath_1.default.extname(normalised), basename = upath_1.default.basename(normalised, extension), filename = (0, filenamify_1.default)(basename, { replacement: '-', maxLength: 250 })
            .trim()
            .replace(/[\s-]+/g, '-');
        return new Path(upath_1.default.join(upath_1.default.dirname(normalised), `${filename}${extension}`));
    }
    constructor(value) {
        super();
        (0, tiny_types_1.ensure)(Path.name, value, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.property)('length', (0, tiny_types_1.isGreaterThan)(0)));
        this.value = upath_1.default.normalize(value);
    }
    join(another) {
        return new Path(upath_1.default.join(this.value, another.value));
    }
    split() {
        return this.value
            .split(Path.Separator)
            .filter(segment => !!segment); // so that we ignore the trailing path separator in absolute paths
    }
    resolve(another) {
        return new Path(upath_1.default.resolve(this.value, another.value));
    }
    relative(another) {
        return new Path(upath_1.default.relative(this.value, another.value));
    }
    directory() {
        return new Path(upath_1.default.dirname(this.value));
    }
    basename() {
        return upath_1.default.basename(this.value);
    }
    isAbsolute() {
        return upath_1.default.isAbsolute(this.value);
    }
    root() {
        return new Path(upath_1.default.parse(this.value).root);
    }
}
Path.Separator = '/';
exports.Path = Path;
//# sourceMappingURL=Path.js.map