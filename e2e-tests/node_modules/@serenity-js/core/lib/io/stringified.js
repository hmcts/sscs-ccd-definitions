"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isPlainObject = exports.stringified = void 0;
const util_1 = require("util");
const Question_1 = require("../screenplay/Question");
const indentationPrefix = '  ';
/**
 * Provides a human-readable description of the {@apilink Answerable<T>}.
 * Similar to [Node util~inspect](https://nodejs.org/api/util.html#utilinspectobject-options).
 *
 * @param value
 * @param config
 *  - inline - Return a single-line string instead of the default potentially multi-line description
 *  - markQuestions - Surround the description of async values, such as Promises and Questions with <<value>>
 */
function stringified(value, config) {
    const { indentationLevel, inline, markQuestions } = { indentationLevel: 0, inline: false, markQuestions: false, ...config };
    if (!isDefined(value)) {
        return (0, util_1.inspect)(value);
    }
    if (Array.isArray(value)) {
        return stringifiedArray(value, { indentationLevel, inline, markQuestions });
    }
    if (isAPromise(value)) {
        return markAs('Promise', markQuestions);
    }
    if (Question_1.Question.isAQuestion(value)) {
        return markAs(value.toString(), markQuestions);
    }
    if (isADate(value)) {
        return value.toISOString();
    }
    if (hasItsOwnToString(value)) {
        return value.toString();
    }
    if (isInspectable(value)) {
        return value.inspect();
    }
    if (isAFunction(value)) {
        return hasName(value)
            ? value.name
            : markAs(`Function`, true);
    }
    if (!hasCustomInspectionFunction(value) && isPlainObject(value) && isSerialisableAsJSON(value)) {
        return stringifiedToJson(value, { indentationLevel, inline, markQuestions });
    }
    return (0, util_1.inspect)(value, { breakLength: Number.POSITIVE_INFINITY, compact: inline ? 3 : false, sorted: false });
}
exports.stringified = stringified;
function indented(line, config) {
    const indentation = config.inline
        ? ''
        : indentationPrefix.repeat(config.indentationLevel || 0);
    return indentation + line;
}
function stringifiedToJson(value, config) {
    const jsonLineIndentation = config.inline ? 0 : indentationPrefix.length;
    const [first, ...rest] = JSON.stringify(value, undefined, jsonLineIndentation).split('\n');
    return [
        first,
        ...rest.map(line => indented(line, config))
    ].join('\n');
}
function stringifiedArray(value, config) {
    const lineSeparator = config.inline ? ' ' : '\n';
    const inspectedItem = (item, index) => {
        const nestedItemConfig = { ...config, indentationLevel: config.indentationLevel + 1 };
        return [
            indented('', nestedItemConfig),
            stringified(item, nestedItemConfig),
            index < value.length - 1 ? ',' : ''
        ].join('');
    };
    return [
        `[`,
        ...value.map(inspectedItem),
        indented(']', config),
    ].join(lineSeparator);
}
function markAs(value, markValue) {
    const [left, right] = markValue && !value.startsWith('<<')
        ? ['<<', '>>']
        : ['', ''];
    return [left, value, right].join('');
}
/**
 * Checks if the value is defined
 *
 * @param v
 */
function isDefined(v) {
    return !!v;
}
/**
 * Checks if the value defines its own `toString` method
 *
 * @param v
 */
function hasItsOwnToString(v) {
    return typeof v === 'object'
        && !!v.toString
        && typeof v.toString === 'function'
        && !isNative(v.toString);
}
/**
 * Checks if the value defines its own `inspect` method
 *
 * @param v
 */
function isInspectable(v) {
    return !!v.inspect && typeof v.inspect === 'function';
}
/**
 * Checks if the value is a {@apilink Date}
 *
 * @param v
 */
function isADate(v) {
    return v instanceof Date;
}
/**
 * Checks if the value is a {@apilink Promise}
 *
 * @param v
 */
function isAPromise(v) {
    return typeof v === 'object'
        && 'then' in v;
}
/**
 * Checks if the value is a named {@apilink Function}
 *
 * @param v
 */
function isAFunction(v) {
    return Object.prototype.toString.call(v) === '[object Function]';
}
/**
 * Checks if the value is has a property called 'name' with a non-empty value.
 *
 * @param v
 */
function hasName(v) {
    return typeof v.name === 'string' && v.name !== '';
}
/**
 * Checks if the value defines its own [`inspect` method](https://nodejs.org/api/util.html#util_util_inspect_custom)
 *
 * @param v
 */
function hasCustomInspectionFunction(v) {
    return v && v[Symbol.for('nodejs.util.inspect.custom')];
}
/**
 * Checks if the value has a good chance of being a plain JavaScript object
 *
 * @param v
 */
function isPlainObject(v) {
    // Basic check for Type object that's not null
    if (typeof v === 'object' && v !== null) {
        // If Object.getPrototypeOf supported, use it
        if (typeof Object.getPrototypeOf === 'function') {
            const proto = Object.getPrototypeOf(v);
            return proto === Object.prototype || proto === null;
        }
        // Otherwise, use internal class
        // This should be reliable as if getPrototypeOf not supported, is pre-ES5
        return Object.prototype.toString.call(v) === '[object Object]';
    }
    // Not an object
    return false;
}
exports.isPlainObject = isPlainObject;
/**
 * Checks if the value is a JSON object that can be stringified
 *
 * @param v
 */
function isSerialisableAsJSON(v) {
    try {
        JSON.stringify(v);
        return true;
    }
    catch {
        return false;
    }
}
/**
 * Inspired by https://davidwalsh.name/detect-native-function
 *
 * @param v
 */
function isNative(v) {
    const toString = Object.prototype.toString, // Used to resolve the internal `{@apilink Class}` of values
    fnToString = Function.prototype.toString, // Used to resolve the decompiled source of functions
    hostConstructor = /^\[object .+?Constructor]$/; // Used to detect host constructors (Safari > 4; really typed array specific)
    // Compile a regexp using a common native method as a template.
    // We chose `Object#toString` because there's a good chance it is not being mucked with.
    const nativeFunctionTemplate = new RegExp('^' +
        // Coerce `Object#toString` to a string
        String(toString)
            // Escape any special regexp characters
            .replace(/[$()*+./?[\\\]^{|}]/g, '\\$&')
            // Replace mentions of `toString` with `.*?` to keep the template generic.
            // Replace thing like `for ...` to support environments like Rhino which add extra info
            // such as method arity.
            .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\])/g, '$1.*?') +
        '$');
    const type = typeof v;
    return type === 'function'
        // Use `Function#toString` to bypass the value's own `toString` method
        // and avoid being faked out.
        ? nativeFunctionTemplate.test(fnToString.call(v))
        // Fallback to a host object check because some environments will represent
        // things like typed arrays as DOM methods which may not conform to the
        // normal native pattern.
        : (v && type === 'object' && hostConstructor.test(toString.call(v))) || false;
}
//# sourceMappingURL=stringified.js.map