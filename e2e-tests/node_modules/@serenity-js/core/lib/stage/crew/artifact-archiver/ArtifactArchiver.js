"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ArtifactArchiver = void 0;
const tiny_types_1 = require("tiny-types");
const events_1 = require("../../../events");
const io_1 = require("../../../io");
const model_1 = require("../../../model");
const Hash_1 = require("./Hash");
/**
 * Stores any {@apilink Artifact|artifacts} emitted via {@apilink ArtifactGenerated} events on the {@apilink FileSystem}
 *
 * ## Registering `ArtifactArchiver` programmatically
 *
 * ```ts
 * import { ArtifactArchiver, configure } from '@serenity-js/core'
 *
 * configure({
 *   crew: [
 *     ArtifactArchiver.storingArtifactsAt(`/target/site/serenity`),
 *   ]
 *   // other Serenity/JS config
 * })
 * ```
 *
 * ## Registering `ArtifactArchiver` using Protractor configuration
 *
 * ```js
 * // protractor.conf.js
 * const { ArtifactArchiver } = require('@serenity-js/core')
 *
 * exports.config = {
 *   framework:     'custom',
 *   frameworkPath: require.resolve('@serenity-js/protractor/adapter'),
 *
 *   serenity: {
 *     crew: [
 *       ArtifactArchiver.storingArtifactsAt('./target/site/serenity'),
 *     ],
 *     // other Serenity/JS config
 *   },
 *   // other Protractor config
 * };
 * ```
 *
 * ## Registering `ArtifactArchiver` using WebdriverIO configuration
 *
 * ```ts
 * // wdio.conf.js
 * import { ArtifactArchiver } from '@serenity-js/core'
 * import { WebdriverIOConfig } from '@serenity-js/webdriverio'
 *
 * export const config: WebdriverIOConfig = {
 *
 *     framework: '@serenity-js/webdriverio',
 *
 *     serenity: {
 *         crew: [
 *             ArtifactArchiver.storingArtifactsAt(`/target/site/serenity`),
 *         ]
 *         // other Serenity/JS config
 *     },
 *     // other WebdriverIO config
 * }
 * ```
 *
 * [ '@serenity-js/core:ArtifactArchiver', { outputDirectory: 'target/site/serenity' } ],
 *
 * @group Stage
 */
class ArtifactArchiver {
    /**
     * Instantiates an `ArtifactArchiver` storing artifacts in a given `destination`.
     * The `destination` directory will be created automatically and recursively if it doesn't exist.
     *
     * @param destination
     */
    static storingArtifactsAt(...destination) {
        (0, tiny_types_1.ensure)('Path to destination directory', destination, (0, tiny_types_1.property)('length', (0, tiny_types_1.isGreaterThan)(0)));
        const pathToDestination = destination.map(segment => new io_1.Path(segment)).reduce((acc, current) => acc.join(current));
        return new ArtifactArchiver(new io_1.FileSystem(pathToDestination));
    }
    /**
     * Instantiates an `ArtifactArchiver` storing artifacts in a given `outputDirectory`.
     * The `outputDirectory` will be created automatically and recursively if it doesn't exist.
     *
     * @param config
     */
    static fromJSON(config) {
        const outputDirectory = (0, tiny_types_1.ensure)('outputDirectory', config.outputDirectory, (0, tiny_types_1.isDefined)(), (0, tiny_types_1.isString)());
        return new ArtifactArchiver(new io_1.FileSystem(io_1.Path.from(outputDirectory)));
    }
    /**
     * @param {FileSystem} fileSystem
     * @param {Stage} [stage]
     *  The stage this {@apilink StageCrewMember} should be assigned to
     */
    constructor(fileSystem, stage) {
        this.fileSystem = fileSystem;
        this.stage = stage;
    }
    assignedTo(stage) {
        this.stage = stage;
        return this;
    }
    /**
     * Handles {@apilink DomainEvent} objects emitted by the {@apilink StageManager}.
     *
     * @see {@apilink StageCrewMember}
     *
     * @listens {ArtifactGenerated}
     * @emits {ArtifactArchived}
     *
     * @param event
     */
    notifyOf(event) {
        if (!(event instanceof events_1.ArtifactGenerated)) {
            // ignore any other events
            return void 0;
        }
        if (event.artifact instanceof model_1.Photo) {
            const filename = this.fileNameFor('photo', event.name, event.artifact, 'png');
            this.archive(filename, event.artifact.base64EncodedValue, 'base64', this.archivisationAnnouncement(event, filename));
        }
        if (event.artifact instanceof model_1.TestReport) {
            const filename = this.fileNameFor('scenario', event.name, event.artifact, 'json');
            this.archive(filename, event.artifact.map(JSON.stringify), 'utf8', this.archivisationAnnouncement(event, filename));
        }
    }
    fileNameFor(prefix, artifactName, artifact, extension) {
        const hash = Hash_1.Hash.of(artifact.base64EncodedValue).short();
        return io_1.Path.fromSanitisedString(
        // Ensure that the file name is shorter than 250 chars, which is safe with all the filesystems
        // note: we can't do that in the Path constructor as the Path can be used to join other paths,
        // so restricting the length of the _path_ itself would not be correct.
        `${prefix.slice(0, 10)}-${urlFriendly(artifactName.value).slice(0, 64)}-${hash}.${extension}`.replace(/-+/g, '-'));
    }
    archive(relativePath, contents, encoding, announce) {
        const id = model_1.CorrelationId.create();
        this.stage.announce(new events_1.AsyncOperationAttempted(new model_1.Name(this.constructor.name), new model_1.Description(`Saving '${relativePath.value}'...`), id, this.stage.currentTime()));
        this.fileSystem.store(relativePath, contents, encoding)
            .then(absolutePath_ => {
            announce(relativePath);
            this.stage.announce(new events_1.AsyncOperationCompleted(id, this.stage.currentTime()));
        })
            .catch(error => {
            this.stage.announce(new events_1.AsyncOperationFailed(error, id, this.stage.currentTime()));
        });
    }
    archivisationAnnouncement(event, relativePathToArtifact) {
        return (absolutePath) => {
            if (event instanceof events_1.ActivityRelatedArtifactGenerated) {
                this.stage.announce(new events_1.ActivityRelatedArtifactArchived(event.sceneId, event.activityId, event.name, event.artifact.constructor, relativePathToArtifact));
            }
            else if (event instanceof events_1.ArtifactGenerated) {
                this.stage.announce(new events_1.ArtifactArchived(event.sceneId, event.name, event.artifact.constructor, relativePathToArtifact));
            }
        };
    }
}
exports.ArtifactArchiver = ArtifactArchiver;
/**
 * @private
 * @param {string} name
 */
function urlFriendly(name) {
    return name.toLocaleLowerCase()
        .replace(/[^\d.a-z-]/g, '-');
}
//# sourceMappingURL=ArtifactArchiver.js.map