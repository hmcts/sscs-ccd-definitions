"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stage = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../errors");
const events_1 = require("../events");
const model_1 = require("../model");
const screenplay_1 = require("../screenplay");
/**
 * Stage is the place where {@apilink Actor|actors} perform.
 *
 * In more technical terms, the Stage is the main event bus propagating {@apilink DomainEvent|DomainEvents}
 * to {@apilink Actor|Actors} it instantiates and {@apilink StageCrewMember|StageCrewMembers} that have been registered with it.
 *
 * It is unlikely that you'll ever need to interact with the `Stage` directly in your tests. Instead, you'll use functions like
 * {@apilink actorCalled} and {@apilink actorInTheSpotlight}.
 *
 * ## Learn more
 * - {@apilink configure}
 * - {@apilink engage}
 *
 * @group Stage
 */
class Stage {
    /**
     * @param cast
     * @param manager
     * @param errors
     * @param clock
     * @param interactionTimeout
     */
    constructor(cast, manager, errors, clock, interactionTimeout) {
        this.cast = cast;
        this.manager = manager;
        this.errors = errors;
        this.clock = clock;
        this.interactionTimeout = interactionTimeout;
        /**
         * Actors instantiated after the scene has started,
         * who will be dismissed when the scene finishes.
         */
        this.actorsOnFrontStage = new Map();
        /**
         * Actors instantiated before the scene has started,
         * who will be dismissed when the test run finishes.
         */
        this.actorsOnBackstage = new Map();
        this.actorsOnStage = this.actorsOnBackstage;
        /**
         * The most recent actor referenced via the {@apilink actor} method
         */
        this.actorInTheSpotlight = undefined;
        this.currentActivity = undefined;
        this.currentScene = Stage.unknownSceneId;
        (0, tiny_types_1.ensure)('Cast', cast, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('StageManager', manager, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('ErrorFactory', errors, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('Clock', clock, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('interactionTimeout', interactionTimeout, (0, tiny_types_1.isDefined)());
    }
    /**
     * An alias for {@apilink Stage.actor}
     *
     * @param name
     */
    theActorCalled(name) {
        return this.actor(name);
    }
    /**
     * Instantiates a new {@apilink Actor} or fetches an existing one
     * identified by their name if they've already been instantiated.
     *
     * @param name
     *  Case-sensitive name of the Actor, e.g. `Alice`
     */
    actor(name) {
        if (!this.instantiatedActorCalled(name)) {
            let actor;
            try {
                const newActor = new screenplay_1.Actor(name, this)
                    .whoCan(new errors_1.RaiseErrors(this), new screenplay_1.ScheduleWork(this.clock, this.interactionTimeout));
                actor = this.cast.prepare(newActor);
                // todo this.manager.notifyOf(ActorStarts)
                // todo: map this in Serenity BDD Reporter so that the "cast" is recorded
            }
            catch (error) {
                throw new errors_1.ConfigurationError(`${this.typeOf(this.cast)} encountered a problem when preparing actor "${name}" for stage`, error);
            }
            if (!(actor instanceof screenplay_1.Actor)) {
                throw new errors_1.ConfigurationError(`Instead of a new instance of actor "${name}", ${this.typeOf(this.cast)} returned ${actor}`);
            }
            this.actorsOnStage.set(name, actor);
        }
        this.actorInTheSpotlight = this.instantiatedActorCalled(name);
        return this.actorInTheSpotlight;
    }
    /**
     * Returns the last {@apilink Actor} instantiated via {@apilink Stage.actor}.
     * Useful when you don't can't or choose not to reference the actor by their name.
     *
     * @throws {LogicError}
     *  If no {@apilink Actor} has been activated yet
     */
    theActorInTheSpotlight() {
        if (!this.actorInTheSpotlight) {
            throw new errors_1.LogicError(`There is no actor in the spotlight yet. Make sure you instantiate one with stage.actor(actorName) before calling this method.`);
        }
        return this.actorInTheSpotlight;
    }
    /**
     * Returns `true` if there is an {@apilink Actor} in the spotlight, `false` otherwise.
     */
    theShowHasStarted() {
        return !!this.actorInTheSpotlight;
    }
    /**
     * Configures the Stage to prepare {@apilink Actor|Actors}
     * instantiated via {@apilink Stage.actor} using the provided {@apilink Cast}.
     *
     * @param actors
     */
    engage(actors) {
        (0, tiny_types_1.ensure)('Cast', actors, (0, tiny_types_1.isDefined)());
        this.cast = actors;
    }
    /**
     * Assigns listeners to be notified of {@apilink DomainEvent|DomainEvents}
     * emitted via {@apilink Stage.announce}.s
     *
     * @param listeners
     */
    assign(...listeners) {
        this.manager.register(...listeners);
    }
    /**
     * Notifies all the assigned listeners of the events,
     * emitting them one by one.
     *
     * @param events
     */
    announce(...events) {
        events.forEach(event => {
            this.announceSingle(event);
        });
    }
    announceSingle(event) {
        if (event instanceof events_1.SceneStarts) {
            this.actorsOnStage = this.actorsOnFrontStage;
        }
        this.manager.notifyOf(event);
        if (event instanceof events_1.SceneFinishes) {
            this.dismiss(this.actorsOnStage);
            this.actorsOnStage = this.actorsOnBackstage;
        }
        if (event instanceof events_1.TestRunFinishes) {
            this.dismiss(this.actorsOnStage);
        }
    }
    /**
     * Returns current time. This method should be used whenever
     * {@apilink DomainEvent} objects are instantiated by you programmatically.
     */
    currentTime() {
        return this.manager.currentTime();
    }
    /**
     * Generates and remembers a {@apilink CorrelationId}
     * for the current scene.
     *
     * This method should be used in custom test runner adapters
     * when instantiating a {@apilink SceneStarts} event.
     *
     * #### Learn more
     * - {@apilink Stage.currentSceneId}
     * - {@apilink CorrelationId}
     */
    assignNewSceneId() {
        // todo: inject an id factory to make it easier to test
        this.currentScene = model_1.CorrelationId.create();
        return this.currentScene;
    }
    /**
     * Returns the {@apilink CorrelationId} for the current scene.
     *
     * #### Learn more
     * - {@apilink Stage.assignNewSceneId}
     */
    currentSceneId() {
        return this.currentScene;
    }
    /**
     * Generates and remembers a {@apilink CorrelationId}
     * for the current {@apilink Activity}.
     *
     * This method should be used in custom test runner adapters
     * when instantiating the {@apilink ActivityStarts} event.
     *
     * #### Learn more
     * - {@apilink Stage.currentActivityId}
     */
    assignNewActivityId(activityDetails) {
        this.currentActivity = {
            id: model_1.CorrelationId.create(),
            details: activityDetails,
        };
        return this.currentActivity.id;
    }
    /**
     * Returns the {@apilink CorrelationId} for the current {@apilink Activity}.
     *
     * #### Learn more
     * - {@apilink Stage.assignNewSceneId}
     */
    currentActivityId() {
        if (!this.currentActivity) {
            throw new errors_1.LogicError(`No activity is being performed. Did you call assignNewActivityId before invoking currentActivityId?`);
        }
        return this.currentActivity.id;
    }
    /**
     * Returns a Promise that will be resolved when any asynchronous
     * post-processing activities performed by Serenity/JS are completed.
     *
     * Invoked in Serenity/JS test runner adapters to inform the test runner when
     * the scenario has finished and when it's safe for the test runner to proceed
     * with the next test, or finish execution.
     */
    waitForNextCue() {
        return this.manager.waitForNextCue();
    }
    createError(errorType, options) {
        var _a;
        return this.errors.create(errorType, {
            location: (_a = this.currentActivity) === null || _a === void 0 ? void 0 : _a.details.location,
            ...options,
        });
    }
    instantiatedActorCalled(name) {
        return this.actorsOnBackstage.has(name)
            ? this.actorsOnBackstage.get(name)
            : this.actorsOnFrontStage.get(name);
    }
    async dismiss(activeActors) {
        const actors = Array.from(activeActors.values());
        if (actors.includes(this.actorInTheSpotlight)) {
            this.actorInTheSpotlight = undefined;
        }
        // Wait for the Photographer to finish taking any screenshots
        await this.manager.waitForAsyncOperationsToComplete();
        const actorsToDismiss = new Map(actors.map(actor => [actor, model_1.CorrelationId.create()]));
        for (const [actor, correlationId] of actorsToDismiss) {
            this.announce(new events_1.AsyncOperationAttempted(new model_1.Name(this.constructor.name), new model_1.Description(`Dismissing ${actor.name}...`), correlationId, this.currentTime()));
        }
        // Try to dismiss each actor
        for (const [actor, correlationId] of actorsToDismiss) {
            try {
                await actor.dismiss();
                this.announce(new events_1.AsyncOperationCompleted(correlationId, this.currentTime()));
            }
            catch (error) {
                this.announce(new events_1.AsyncOperationFailed(error, correlationId, this.currentTime())); // todo: serialise the error!
            }
        }
        activeActors.clear();
    }
    typeOf(cast) {
        return cast.constructor === Object
            ? 'Cast'
            : cast.constructor.name;
    }
}
Stage.unknownSceneId = new model_1.CorrelationId('unknown');
exports.Stage = Stage;
//# sourceMappingURL=Stage.js.map