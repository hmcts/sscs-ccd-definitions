"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DomainEventQueues = void 0;
const errors_1 = require("../../errors");
const events_1 = require("../../events");
const format_1 = require("../../io/format");
const DomainEventQueue_1 = require("./DomainEventQueue");
/**
 * @group Stage
 */
class DomainEventQueues {
    constructor() {
        this.queueIndex = [];
        this.queues = new Map();
        this.holdingBay = new DomainEventQueue_1.DomainEventQueue();
    }
    enqueue(event) {
        if (this.shouldStartNewQueueFor(event)) {
            this.queues.set(this.queueIdFor(event), new DomainEventQueue_1.DomainEventQueue(event, ...this.holdingBay.drain()));
        }
        else if (this.hasNoQueuesReadyFor(event)) {
            this.holdingBay.enqueue(event);
        }
        else {
            this.queues.get(this.queueIdFor(event)).enqueue(event);
        }
    }
    forEach(callback) {
        this.queues.forEach(callback);
    }
    drainQueueFor(sceneId) {
        for (const [key, queue] of this.queues) {
            if (sceneId.equals(queue.sceneId)) {
                const events = queue.drain();
                this.queues.delete(key);
                return events;
            }
        }
        throw new errors_1.LogicError((0, format_1.d) `No domain event queue found for scene ${sceneId}`);
    }
    shouldStartNewQueueFor(event) {
        return (event instanceof events_1.SceneSequenceDetected || event instanceof events_1.SceneStarts)
            && !this.queues.has(this.queueIdFor(event));
    }
    hasNoQueuesReadyFor(event) {
        return this.queues.size === 0
            || !this.queues.has(this.queueIdFor(event));
    }
    queueIdFor(event) {
        const exactMatch = this.queueIndex.find(entry => entry.sceneId.equals(event.sceneId));
        if (exactMatch) {
            return exactMatch.queueId;
        }
        if (!(event instanceof events_1.SceneStarts)) {
            const sameScenarioMatch = this.queueIndex.find(entry => entry.details &&
                entry.details.equals(event.details));
            if (sameScenarioMatch) {
                this.queueIndex.push({
                    sceneId: event.sceneId,
                    details: event.details || sameScenarioMatch.details,
                    queueId: sameScenarioMatch.queueId,
                });
                return sameScenarioMatch.queueId;
            }
        }
        const newQueueId = Symbol();
        this.queueIndex.push({
            sceneId: event.sceneId,
            details: event.details,
            queueId: newQueueId,
        });
        return newQueueId;
    }
}
exports.DomainEventQueues = DomainEventQueues;
//# sourceMappingURL=DomainEventQueues.js.map