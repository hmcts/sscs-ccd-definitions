"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StageManager = void 0;
const events_1 = require("../events");
/**
 * @group Stage
 */
class StageManager {
    constructor(cueTimeout, clock) {
        this.cueTimeout = cueTimeout;
        this.clock = clock;
        this.subscribers = [];
        this.wip = new WIP(cueTimeout, clock);
    }
    register(...subscribers) {
        this.subscribers.push(...subscribers);
    }
    deregister(subscriber) {
        this.subscribers.splice(this.subscribers.indexOf(subscriber), 1);
    }
    notifyOf(event) {
        this.wip.recordIfAsync(event);
        this.subscribers.forEach(crewMember => crewMember.notifyOf(event));
    }
    waitForAsyncOperationsToComplete() {
        return new Promise((resolve, reject) => {
            const timeout = setTimeout(() => {
                clearInterval(interval);
                return resolve();
            }, this.cueTimeout.inMilliseconds());
            const interval = setInterval(() => {
                if (this.wip.hasAllOperationsCompleted()) {
                    clearTimeout(timeout);
                    clearInterval(interval);
                    return resolve();
                }
            }, 10);
        });
    }
    async waitForNextCue() {
        await this.waitForAsyncOperationsToComplete();
        if (this.wip.hasFailedOperations()) {
            const error = new Error(this.wip.descriptionOfFailedOperations());
            this.wip.resetFailedOperations();
            throw error;
        }
        if (this.wip.hasActiveOperations()) {
            throw new Error(this.wip.descriptionOfTimedOutOperations());
        }
    }
    currentTime() {
        return this.clock.now();
    }
}
exports.StageManager = StageManager;
/**
 * @package
 */
class WIP {
    constructor(cueTimeout, clock) {
        this.cueTimeout = cueTimeout;
        this.clock = clock;
        this.wip = new Map();
        this.failedOperations = [];
    }
    recordIfAsync(event) {
        if (event instanceof events_1.AsyncOperationAttempted) {
            this.set(event.correlationId, {
                name: event.name,
                description: event.description,
                startedAt: event.timestamp,
            });
        }
        if (event instanceof events_1.AsyncOperationCompleted) {
            this.delete(event.correlationId);
        }
        if (event instanceof events_1.AsyncOperationFailed) {
            const original = this.get(event.correlationId);
            this.failedOperations.push({
                name: original.name,
                description: original.description,
                startedAt: original.startedAt,
                duration: event.timestamp.diff(original.startedAt),
                error: event.error,
            });
            this.delete(event.correlationId);
        }
    }
    hasAllOperationsCompleted() {
        return this.wip.size === 0;
    }
    hasActiveOperations() {
        return this.wip.size > 0;
    }
    hasFailedOperations() {
        return this.failedOperations.length > 0;
    }
    descriptionOfTimedOutOperations() {
        const now = this.clock.now();
        return this.activeOperations().reduce((acc, op) => acc.concat(`${now.diff(op.startedAt)} - [${op.name.value}] ${op.description.value}`), [`${this.header(this.wip.size)} within a ${this.cueTimeout} cue timeout:`]).join('\n');
    }
    descriptionOfFailedOperations() {
        let message = `${this.header(this.failedOperations.length)}:\n`;
        this.failedOperations.forEach((op) => {
            message += `[${op.name.value}] ${op.description.value} - ${op.error.stack}\n---\n`;
        });
        return message;
    }
    resetFailedOperations() {
        this.failedOperations.length = 0;
    }
    activeOperations() {
        return Array.from(this.wip.values());
    }
    header(numberOfFailures) {
        return numberOfFailures === 1
            ? `1 async operation has failed to complete`
            : `${numberOfFailures} async operations have failed to complete`;
    }
    set(correlationId, details) {
        return this.wip.set(correlationId, details);
    }
    get(correlationId) {
        return this.wip.get(this.asReference(correlationId));
    }
    delete(correlationId) {
        this.wip.delete(this.asReference(correlationId));
    }
    asReference(key) {
        for (const [k, v_] of this.wip.entries()) {
            if (k.equals(key)) {
                return k;
            }
        }
        return undefined; // eslint-disable-line unicorn/no-useless-undefined
    }
}
//# sourceMappingURL=StageManager.js.map