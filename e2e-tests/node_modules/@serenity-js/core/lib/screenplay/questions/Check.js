"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Check = void 0;
const io_1 = require("../../io");
const Task_1 = require("../Task");
const expectations_1 = require("./expectations");
/**
 * A [flow control statement](https://en.wikipedia.org/wiki/Control_flow)
 * that enables an {@apilink Actor} to decide between two alternate series of {@apilink Activity|activities}.
 *
 * Think of it as a Screenplay Pattern equivalent of the traditional `if` statement.
 *
 * ## Choose between two alternative sequences of activities
 *
 * ```ts
 * import { equals } from '@serenity-js/assertions'
 * import { actorCalled, Check } from '@serenity-js/core'
 *
 * await actorCalled('Chuck').attemptsTo(
 *   Check.whether(process.env.MODE, equals('prod'))
 *     .andIfSo(
 *       LogInAsProdUser(),
 *     )
 *     .otherwise(
 *       LogInAsTestUser(),
 *     )
 * )
 * ```
 *
 * ## Perform a sequence of activities when a condition is met
 *
 * ```ts
 * import { actorCalled, Check } from '@serenity-js/core'
 * import { isVisible } from '@serenity-js/web'
 *
 * await actorCalled('Chuck').attemptsTo(
 *   Check.whether(CookieConsentBanner(), isVisible())
 *     .andIfSo(
 *         AcceptNecessaryCookies(),
 *     )
 * )
 * ```
 *
 * @group Activities
 */
class Check extends Task_1.Task {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    static whether(actual, expectation) {
        return {
            andIfSo: (...activities) => new Check(actual, expectation, activities),
        };
    }
    constructor(actual, expectation, activities, alternativeActivities = []) {
        super((0, io_1.d) `#actor checks whether ${actual} does ${expectation}`);
        this.actual = actual;
        this.expectation = expectation;
        this.activities = activities;
        this.alternativeActivities = alternativeActivities;
    }
    /**
     * @param alternativeActivities
     *  A sequence of {@apilink Activity|activities} to perform when the {@apilink Expectation} is not met.
     */
    otherwise(...alternativeActivities) {
        return new Check(this.actual, this.expectation, this.activities, alternativeActivities);
    }
    /**
     * @inheritDoc
     */
    async performAs(actor) {
        const outcome = await actor.answer(this.expectation.isMetFor(this.actual));
        return outcome instanceof expectations_1.ExpectationMet
            ? actor.attemptsTo(...this.activities)
            : actor.attemptsTo(...this.alternativeActivities);
    }
}
exports.Check = Check;
//# sourceMappingURL=Check.js.map