"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpectationDetails = void 0;
const tiny_types_1 = require("tiny-types");
const io_1 = require("../../../io");
const model_1 = require("../../../model");
const Unanswered_1 = require("../Unanswered");
/**
 * Used with {@apilink ExpectationOutcome} to describe an {@apilink Expectation} and the arguments it's been executed with.
 *
 * @group Expectations
 */
class ExpectationDetails extends tiny_types_1.TinyType {
    static of(functionName, ...functionArguments) {
        return new ExpectationDetails(new model_1.Name(functionName), functionArguments);
    }
    static fromJSON(o) {
        return new ExpectationDetails(model_1.Name.fromJSON(o.name), o.args.map(arg => {
            if (arg.type === Unanswered_1.Unanswered.name) {
                return new Unanswered_1.Unanswered();
            }
            if (arg.type === ExpectationDetails.name) {
                return ExpectationDetails.fromJSON(arg.value);
            }
            // must be a JSONValue then
            return arg.value;
        }));
    }
    constructor(name, args) {
        super();
        this.name = name;
        this.args = args;
        (0, tiny_types_1.ensure)('name', name, (0, tiny_types_1.isDefined)());
        (0, tiny_types_1.ensure)('args', args, (0, tiny_types_1.isArray)());
    }
    toString() {
        const argumentValues = this.args.map(arg => arg instanceof ExpectationDetails
            ? arg.toString()
            : (0, io_1.inspected)(arg, { compact: true })).join(', ');
        return `${this.name.value}(${argumentValues})`;
    }
    toJSON() {
        return {
            name: this.name.value,
            args: this.args.map(arg => ({
                type: (0, io_1.typeOf)(arg),
                value: arg['toJSON']
                    ? arg.toJSON()
                    : arg,
            })),
        };
    }
}
exports.ExpectationDetails = ExpectationDetails;
//# sourceMappingURL=ExpectationDetails.js.map