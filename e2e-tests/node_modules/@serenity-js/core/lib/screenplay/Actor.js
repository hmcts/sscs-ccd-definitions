"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Actor = void 0;
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../errors");
const events_1 = require("../events");
const io_1 = require("../io");
const model_1 = require("../model");
const screenplay_1 = require("../screenplay");
const Activity_1 = require("./Activity");
const Question_1 = require("./Question");
/**
 * **Actors** represent **people** and **external systems** interacting with the system under test.
 * Their role is to perform {@apilink Activity|activities} that demonstrate how to accomplish a given goal.
 *
 * Actors are the core building block of the [Screenplay Pattern](/handbook/design/screenplay-pattern),
 * along with {@apilink Ability|Abilities}, {@apilink Interaction|Interactions}, {@apilink Task|Tasks}, and {@apilink Question|Questions}.
 * Actors are also the first thing you see in a typical Serenity/JS test scenario.
 *
 * ![Screenplay Pattern](/images/design/serenity-js-screenplay-pattern.png)
 *
 * Learn more about:
 * - {@apilink Cast}
 * - {@apilink Stage}
 * - {@apilink Ability|Abilities}
 * - {@apilink Activity|Activities}
 * - {@apilink Interaction|Interactions}
 * - {@apilink Task|Tasks}
 * - {@apilink Question|Questions}
 *
 * ## Representing people and systems as actors
 *
 * To use a Serenity/JS {@apilink Actor}, all you need is to say their name:
 *
 * ```typescript
 * import { actorCalled } from '@serenity-js/core'
 *
 * actorCalled('Alice')
 * // returns: Actor
 * ```
 *
 * Serenity/JS actors perform within the scope of a test scenario, so the first time you invoke {@apilink actorCalled},
 * Serenity/JS instantiates a new actor from the default {@apilink Cast} of actors (or any custom cast you might have {@apilink configured|configured}).
 * Any subsequent invocations of this function within the scope of the same test scenario retrieve the already instantiated actor, identified by their name.
 *
 * ```typescript
 * import { actorCalled } from '@serenity-js/core'
 *
 * actorCalled('Alice')    // instantiates Alice
 * actorCalled('Bob')      // instantiates Bob
 * actorCalled('Alice')    // retrieves Alice, since she's already been instantiated
 * ```
 *
 * Serenity/JS scenarios can involve as many or as few actors as you need to model the given business workflow.
 * For example, you might want to use **multiple actors** in test scenarios that model how **different people** perform different parts of a larger business process, such as reviewing and approving a loan application.
 * It is also quite common to introduce **supporting actors** to perform **administrative tasks**, like setting up test data and environment, or **audit tasks**, like checking the logs or messages emitted to a message queue
 * by the system under test.
 *
 * :::info The Stan Lee naming convention
 * Actor names can be much more than just simple identifiers like `Alice` or `Bob`. While you can give your actors any names you like, a good convention to follow is to give them
 * names indicating the [personae](https://articles.uie.com/goodwin_interview/) they represent or the role they play in the system.
 *
 * Just like the characters in [Stan Lee](https://en.wikipedia.org/wiki/Stan_Lee) graphic novels,
 * actors in Serenity/JS test scenarios are often given alliterate names as a mnemonic device.
 * Names like "Adam the Admin", "Edna the Editor", "Trevor the Traveller", are far more memorable than a generic "UI user" or "API user".
 * They're also much easier for people to associate with the context, constraints, and affordances of the given actor.
 * :::
 *
 * @group Screenplay Pattern
 */
class Actor {
    constructor(name, stage, abilities = new Map()) {
        this.name = name;
        this.stage = stage;
        this.abilities = abilities;
    }
    /**
     * Retrieves actor's {@apilink Ability} of `abilityType`, or one that extends `abilityType`.
     *
     * Please note that this method performs an {@apilink instanceof} check against abilities
     * given to this actor via {@apilink Actor.whoCan}.
     *
     * Please also note that {@apilink Actor.whoCan} performs the same check when abilities are assigned to the actor
     * to ensure the actor has at most one instance of a given ability type.
     *
     * @param abilityType
     */
    abilityTo(abilityType) {
        const found = this.findAbilityTo(abilityType);
        if (!found) {
            if (this.abilities.size > 0) {
                throw new errors_1.ConfigurationError(`${this.name} can ${Array.from(this.abilities.keys()).map(type => type.name).join(', ')}. ` +
                    `They can't, however, ${abilityType.name} yet. ` +
                    `Did you give them the ability to do so?`);
            }
            throw new errors_1.ConfigurationError(`${this.name} can't ${abilityType.name} yet. ` +
                `Did you give them the ability to do so?`);
        }
        return found;
    }
    /**
     * Instructs the actor to attempt to perform a number of {@apilink Activity|activities},
     * so either {@apilink Task|Tasks} or {@apilink Interaction|Interactions}),
     * one by one.
     *
     * @param {...activities: Activity[]} activities
     */
    attemptsTo(...activities) {
        return activities
            .map(activity => new TrackedActivity(activity, this.stage))
            .reduce((previous, current) => {
            return previous
                // synchronise async operations like taking screenshots
                .then(() => this.stage.waitForNextCue())
                .then(() => {
                /* todo: add an execution strategy */
                return current.performAs(this);
            });
        }, this.initialiseAbilities());
    }
    /**
     * Gives this Actor a list of {@apilink Ability|abilities} they can use
     * to interact with the system under test or the test environment.
     *
     * @param abilities
     *  A vararg list of abilities to give the actor
     *
     * @returns
     *  The actor with newly gained abilities
     *
     * @throws {@apilink ConfigurationError}
     *  Throws a ConfigurationError if the actor already has an ability of this type.
     */
    whoCan(...abilities) {
        abilities.forEach(ability => this.acquireAbility(ability));
        return this;
    }
    /**
     * @param answerable -
     *  An {@apilink Answerable} to answer (resolve the value of).
     *
     * @returns
     *  The answer to the Answerable
     */
    answer(answerable) {
        function isAPromise(v) {
            return Object.prototype.hasOwnProperty.call(v, 'then');
        }
        function isDefined(v) {
            return !(v === undefined || v === null);
        }
        if (isDefined(answerable) && isAPromise(answerable)) {
            return answerable;
        }
        if (isDefined(answerable) && Question_1.Question.isAQuestion(answerable)) {
            return this.answer(answerable.answeredBy(this));
        }
        return Promise.resolve(answerable);
    }
    /**
     * Announce collection of an {@apilink Artifact} so that it can be picked up by a {@apilink StageCrewMember}.
     *
     * @param artifact
     * @param name
     */
    collect(artifact, name) {
        this.stage.announce(new events_1.ActivityRelatedArtifactGenerated(this.stage.currentSceneId(), this.stage.currentActivityId(), this.nameFrom(name || new model_1.Name(artifact.constructor.name)), artifact, this.stage.currentTime()));
    }
    /**
     * Instructs the actor to invoke {@apilink Discardable.discard} method on any
     * {@apilink Discardable} {@apilink Ability} it's been configured with.
     */
    dismiss() {
        return this.findAbilitiesOfType('discard')
            .reduce((previous, ability) => previous.then(() => ability.discard()), Promise.resolve(void 0));
    }
    /**
     * Returns a human-readable, string representation of this actor and their abilities.
     *
     * **PRO TIP:** To get the name of the actor, use {@apilink Actor.name}
     */
    toString() {
        const abilities = Array.from(this.abilities.values()).map(ability => ability.constructor.name);
        return `Actor(name=${this.name}, abilities=[${abilities.join(', ')}])`;
    }
    initialiseAbilities() {
        return this.findAbilitiesOfType('initialise', 'isInitialised')
            .filter(ability => !ability.isInitialised())
            .reduce((previous, ability) => previous
            .then(() => ability.initialise())
            .catch(error => {
            throw new errors_1.TestCompromisedError(`${this.name} couldn't initialise the ability to ${ability.constructor.name}`, error);
        }), Promise.resolve(void 0));
    }
    findAbilitiesOfType(...methodNames) {
        const abilitiesFrom = (map) => Array.from(map.values());
        const abilitiesWithDesiredMethods = (ability) => methodNames.every(methodName => typeof (ability[methodName]) === 'function');
        return abilitiesFrom(this.abilities)
            .filter(abilitiesWithDesiredMethods);
    }
    findAbilityTo(doSomething) {
        const abilityType = this.mostGenericTypeOf(doSomething);
        return this.abilities.get(abilityType);
    }
    acquireAbility(ability) {
        if (!(ability instanceof screenplay_1.Ability)) {
            throw new errors_1.ConfigurationError(`Custom abilities must extend Ability from '@serenity-js/core'. Received ${(0, io_1.typeOf)(ability)}`);
        }
        const abilityType = this.mostGenericTypeOf(ability.constructor);
        this.abilities.set(abilityType, ability);
    }
    mostGenericTypeOf(abilityType) {
        const parentType = Object.getPrototypeOf(abilityType);
        return !parentType || parentType === screenplay_1.Ability
            ? abilityType
            : this.mostGenericTypeOf(parentType);
    }
    /**
     * Instantiates a {@apilink Name} based on the string value of the parameter,
     * or returns the argument if it's already an instance of {@apilink Name}.
     *
     * @param maybeName
     */
    nameFrom(maybeName) {
        return typeof maybeName === 'string'
            ? new model_1.Name(maybeName)
            : maybeName;
    }
}
exports.Actor = Actor;
class ActivityDescriber {
    describe(activity, actor) {
        const template = activity.toString() === ({}).toString()
            ? `#actor performs ${activity.constructor.name}`
            : activity.toString();
        return new model_1.Name(this.includeActorName(template, actor));
    }
    includeActorName(template, actor) {
        return template.replace('#actor', actor.name);
    }
}
class OutcomeMatcher {
    outcomeFor(error) {
        return (0, tiny_types_1.match)(error)
            .when(errors_1.ImplementationPendingError, _ => new model_1.ImplementationPending(error))
            .when(errors_1.TestCompromisedError, _ => new model_1.ExecutionCompromised(error))
            .when(errors_1.AssertionError, _ => new model_1.ExecutionFailedWithAssertionError(error))
            .when(Error, _ => /AssertionError/.test(error.constructor.name) // mocha
            ? new model_1.ExecutionFailedWithAssertionError(error)
            : new model_1.ExecutionFailedWithError(error))
            .else(_ => new model_1.ExecutionFailedWithError(error));
    }
}
class TrackedActivity extends Activity_1.Activity {
    constructor(activity, stage) {
        super(activity.toString(), activity.instantiationLocation());
        this.activity = activity;
        this.stage = stage;
    }
    performAs(actor) {
        const sceneId = this.stage.currentSceneId();
        const details = new model_1.ActivityDetails(TrackedActivity.describer.describe(this.activity, actor), this.activity.instantiationLocation());
        const activityId = this.stage.assignNewActivityId(details);
        const [activityStarts, activityFinished] = this.activity instanceof screenplay_1.Interaction
            ? [events_1.InteractionStarts, events_1.InteractionFinished]
            : [events_1.TaskStarts, events_1.TaskFinished];
        return Promise.resolve()
            .then(() => this.stage.announce(new activityStarts(sceneId, activityId, details, this.stage.currentTime())))
            .then(() => this.activity.performAs(actor))
            .then(() => {
            const outcome = new model_1.ExecutionSuccessful();
            this.stage.announce(new activityFinished(sceneId, activityId, details, outcome, this.stage.currentTime()));
        })
            .catch(error => {
            const outcome = TrackedActivity.outcomes.outcomeFor(error);
            this.stage.announce(new activityFinished(sceneId, activityId, details, outcome, this.stage.currentTime()));
            throw error;
        });
    }
}
TrackedActivity.describer = new ActivityDescriber();
TrackedActivity.outcomes = new OutcomeMatcher();
//# sourceMappingURL=Actor.js.map