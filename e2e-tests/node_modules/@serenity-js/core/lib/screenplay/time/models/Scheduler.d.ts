import { Clock } from './Clock';
import { DelayedCallback } from './DelayedCallback';
import { Duration } from './Duration';
import { RepeatUntilLimits } from './RepeatUntilLimits';
/**
 * @group Time
 */
export declare class Scheduler {
    private readonly clock;
    private readonly interactionTimeout;
    private remainingCallbacks;
    private completedCallbacks;
    private failedCallbacks;
    private timer;
    /**
     * @param clock
     * @param interactionTimeout
     *  The maximum amount of time to give to a callback to complete before throwing an error
     */
    constructor(clock: Clock, interactionTimeout: Duration);
    /**
     * Schedules a callback function to be invoked after a delay
     *
     * @param delay
     * @param callback
     */
    after<Result>(delay: Duration, callback: DelayedCallback<Result>): Promise<Result>;
    /**
     * Returns a `Promise` to be resolved after a `delay`
     *
     * @param delay
     */
    waitFor(delay: Duration): Promise<void>;
    /**
     * Schedules a callback function to be repeated, according to configured limits.
     *
     * @param callback
     * @param limits
     */
    repeatUntil<Result>(callback: DelayedCallback<Result>, limits?: RepeatUntilLimits<Result>): Promise<Result>;
    start(): void;
    isRunning(): boolean;
    stop(): void;
    invokeCallbacksScheduledForNext(duration: Duration): void;
    private invokeCallbacksScheduledUntil;
    private invoke;
    private receiptFor;
}
//# sourceMappingURL=Scheduler.d.ts.map