"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scheduler = void 0;
const errors_1 = require("../../../errors");
const Duration_1 = require("./Duration");
/**
 * @group Time
 */
class Scheduler {
    /**
     * @param clock
     * @param interactionTimeout
     *  The maximum amount of time to give to a callback to complete before throwing an error
     */
    constructor(clock, interactionTimeout) {
        this.clock = clock;
        this.interactionTimeout = interactionTimeout;
        this.remainingCallbacks = new Map();
        this.completedCallbacks = new Map();
        this.failedCallbacks = new Map();
    }
    /**
     * Schedules a callback function to be invoked after a delay
     *
     * @param delay
     * @param callback
     */
    after(delay, callback) {
        return this.repeatUntil(callback, {
            maxInvocations: 1,
            delayBetweenInvocations: () => delay,
            timeout: this.interactionTimeout,
        });
    }
    /**
     * Returns a `Promise` to be resolved after a `delay`
     *
     * @param delay
     */
    waitFor(delay) {
        return this.repeatUntil(() => void 0, {
            maxInvocations: 1,
            delayBetweenInvocations: () => delay,
            // make sure waitFor doesn't get terminated before it's resolved
            timeout: this.interactionTimeout.plus(delay),
        });
    }
    /**
     * Schedules a callback function to be repeated, according to configured limits.
     *
     * @param callback
     * @param limits
     */
    async repeatUntil(callback, limits = {}) {
        const { maxInvocations = Number.POSITIVE_INFINITY, delayBetweenInvocations = noDelay, timeout = this.interactionTimeout, exitCondition = noEarlyExit, errorHandler = rethrowErrors, } = limits;
        this.remainingCallbacks.set(callback, {
            exitCondition: exitCondition,
            currentInvocation: 0,
            invocationsLeft: maxInvocations,
            delayBetweenInvocations,
            startedAt: this.clock.now(),
            timeout,
            errorHandler,
            result: undefined,
        });
        return this.receiptFor(callback);
    }
    start() {
        if (!this.timer) {
            this.timer = setInterval(() => this.invokeCallbacksScheduledUntil(this.clock.now()), 100);
        }
    }
    isRunning() {
        return Boolean(this.timer);
    }
    stop() {
        if (this.timer) {
            clearInterval(this.timer);
            this.timer = undefined;
            for (const [callback, info] of this.remainingCallbacks) {
                this.remainingCallbacks.delete(callback);
                this.failedCallbacks.set(callback, {
                    ...info,
                    error: new errors_1.OperationInterruptedError(`Scheduler stopped before executing callback ${callback}`)
                });
            }
        }
    }
    invokeCallbacksScheduledForNext(duration) {
        this.invokeCallbacksScheduledUntil(this.clock.now().plus(duration));
    }
    invokeCallbacksScheduledUntil(timestamp) {
        for (const [callback, info] of this.remainingCallbacks) {
            const { startedAt, currentInvocation, delayBetweenInvocations } = info;
            const expectedInvocationTime = startedAt.plus(delayBetweenInvocations(currentInvocation));
            if (expectedInvocationTime.isBeforeOrEqual(timestamp)) {
                this.invoke(callback);
            }
        }
    }
    invoke(callback) {
        const info = this.remainingCallbacks.get(callback);
        this.remainingCallbacks.delete(callback);
        Promise.resolve()
            .then(async () => {
            const timeoutExpired = info.startedAt.plus(info.timeout).isBefore(this.clock.now());
            const isLastInvocation = info.invocationsLeft === 1;
            if (info.invocationsLeft === 0) {
                return {
                    hasCompleted: true,
                };
            }
            try {
                if (timeoutExpired) {
                    throw new errors_1.TimeoutExpiredError(`Timeout of ${info.timeout} has expired`);
                }
                const result = await callback({ currentTime: this.clock.now(), i: info.currentInvocation });
                return {
                    result,
                    hasCompleted: info.exitCondition(result) || isLastInvocation,
                };
            }
            catch (error) {
                info.errorHandler(error, info.result);
                // if the errorHandler didn't throw, it's a recoverable error
                return {
                    error,
                    hasCompleted: isLastInvocation,
                };
            }
        })
            .then(({ result, error, hasCompleted }) => {
            if (hasCompleted) {
                this['completedCallbacks'].set(callback, {
                    ...info,
                    result: result !== null && result !== void 0 ? result : info.result,
                    error,
                });
            }
            else {
                this['remainingCallbacks'].set(callback, {
                    ...info,
                    currentInvocation: info.currentInvocation + 1,
                    invocationsLeft: info.invocationsLeft - 1,
                    result: result !== null && result !== void 0 ? result : info.result,
                    error,
                });
            }
        })
            .catch(error => {
            this.failedCallbacks.set(callback, { ...info, error });
        });
    }
    receiptFor(callback) {
        return new Promise((resolve, reject) => {
            const timer = setInterval(() => {
                if (this.failedCallbacks.has(callback)) {
                    clearInterval(timer);
                    return reject(this.failedCallbacks.get(callback).error);
                }
                if (this.completedCallbacks.has(callback)) {
                    clearInterval(timer);
                    return resolve(this.completedCallbacks.get(callback).result);
                }
            }, 25);
        });
    }
}
exports.Scheduler = Scheduler;
function noDelay() {
    return Duration_1.Duration.ofMilliseconds(0);
}
function noEarlyExit() {
    return false;
}
function rethrowErrors(error) {
    throw error;
}
//# sourceMappingURL=Scheduler.js.map