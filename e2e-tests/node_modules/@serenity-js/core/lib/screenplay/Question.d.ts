/// <reference types="node" />
import * as util from 'util';
import { UsesAbilities } from './abilities';
import { Answerable } from './Answerable';
import { Interaction } from './Interaction';
import { Optional } from './Optional';
import { AnswersQuestions } from './questions/AnswersQuestions';
import { RecursivelyAnswered } from './RecursivelyAnswered';
import { WithAnswerableProperties } from './WithAnswerableProperties';
/**
 * **Questions** describe how {@apilink Actor|actors} should query the system under test or the test environment to retrieve some information.
 *
 * Questions are the core building block of the [Screenplay Pattern](/handbook/design/screenplay-pattern),
 * along with {@apilink Actor|Actors}, {@apilink Ability|Abilities}, {@apilink Interaction|Interactions}, and {@apilink Task|Tasks}.
 *
 * ![Screenplay Pattern](/images/design/serenity-js-screenplay-pattern.png)
 *
 * Learn more about:
 * - {@apilink Actor}
 * - {@apilink Ability|Abilities}
 * - {@apilink Interaction}
 * - {@apilink QuestionAdapter}
 *
 * ## Implementing a basic custom Question
 *
 * ```ts
 *  import { actorCalled, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { Ensure, equals } from '@serenity-js/assertions'
 *
 *  const LastItemOf = <T>(list: T[]): Question<T> =>
 *    Question.about('last item from the list', (actor: AnswersQuestions & UsesAbilities) => {
 *      return list[list.length - 1]
 *    });
 *
 *  await actorCalled('Quentin').attemptsTo(
 *    Ensure.that(LastItemFrom([1,2,3]), equals(3)),
 *  )
 * ```
 *
 * ## Implementing a Question that uses an Ability
 *
 * Just like the {@apilink Interaction|interactions}, a {@apilink Question}
 * also can use {@apilink Actor|actor's} {@apilink Ability|abilities}.
 *
 * Here, we use the ability to {@apilink CallAnApi} to retrieve a property of
 * an HTTP response.
 *
 * ```ts
 *  import { AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 *  import { CallAnApi } from '@serenity-js/rest'
 *
 *  const TextOfLastResponseStatus = () =>
 *    Question.about<number>(`the text of the last response status`, actor => {
 *      return CallAnApi.as(actor).mapLastResponse(response => response.statusText)
 *    })
 * ```
 *
 * #### Learn more
 * - {@apilink CallAnApi}
 * - {@apilink LastResponse}
 *
 * ## Mapping answers to other questions
 *
 * Apart from retrieving information, {@apilink Question|questions} can be used to transform information retrieved by other questions.
 *
 * Here, we use the factory method {@apilink Question.about} to produce a question that makes the received {@apilink Actor|actor}
 * answer {@apilink LastResponse.status} and then compare it against some expected value.
 *
 * ```ts
 * import { actorCalled, AnswersQuestions, UsesAbilities, Question } from '@serenity-js/core'
 * import { CallAnApi, LastResponse } from '@serenity-js/rest'
 * import { Ensure, equals } from '@serenity-js/assertions'
 *
 * const RequestWasSuccessful = () =>
 *   Question.about<number>(`the text of the last response status`, actor => {
 *     return LastResponse.status().answeredBy(actor) === 200;
 *   });
 *
 * await actorCalled('Quentin')
 *   .whoCan(CallAnApi.at('https://api.example.org/'));
 *   .attemptsTo(
 *     Send.a(GetRequest.to('/books/0-688-00230-7')),
 *     Ensure.that(RequestWasSuccessful(), isTrue()),
 *   );
 * ```
 *
 * Note that the above example is for demonstration purposes only, Serenity/JS provides an easier way to
 * verify the response status of the {@apilink LastResponse}:
 *
 * ```ts
 * import { actorCalled } from '@serenity-js/core'
 * import { CallAnApi, LastResponse } from '@serenity-js/rest'
 * import { Ensure, equals } from '@serenity-js/assertions'
 *
 * await actorCalled('Quentin')
 *   .whoCan(CallAnApi.at('https://api.example.org/'));
 *   .attemptsTo(
 *     Send.a(GetRequest.to('/books/0-688-00230-7')),
 *     Ensure.that(LastResponse.status(), equals(200)),
 *   );
 * ```
 *
 * @group Screenplay Pattern
 */
export declare abstract class Question<T> {
    /**
     * Factory method that simplifies the process of defining custom questions.
     *
     * #### Defining a custom question
     *
     * ```ts
     * import { Question } from '@serenity-js/core'
     *
     * const EnvVariable = (name: string) =>
     *   Question.about(`the ${ name } env variable`, actor => process.env[name])
     * ```
     *
     * @param description
     * @param body
     */
    static about<Result_Type>(description: string, body: (actor: AnswersQuestions & UsesAbilities) => Promise<Result_Type> | Result_Type): QuestionAdapter<Awaited<Result_Type>>;
    /**
     * Generates a {@apilink QuestionAdapter} that recursively resolves
     * any {@apilink Answerable} fields of the provided object,
     * including {@apilink Answerable} fields of {@apilink WithAnswerableProperties|nested objects}.
     *
     * Optionally, the method accepts `overrides` to be shallow-merged with the fields of the original `source`,
     * producing a new merged object.
     *
     * Overrides are applied from left to right, with subsequent objects overwriting property assignments of the previous ones.
     *
     * #### Resolving an object recursively using `Question.fromObject`
     *
     * ```ts
     * import { actorCalled, Question } from '@serenity-js/core'
     * import { Send, PostRequest } from '@serenity-js/rest'
     * import { By, Text, PageElement } from '@serenity-js/web'
     *
     * await actorCalled('Daisy')
     *   .whoCan(CallAnApi.at('https://api.example.org'))
     *   .attemptsTo(
     *     Send.a(
     *       PostRequest.to('/products/2')
     *         .with(
     *           Question.fromObject({
     *             name: Text.of(PageElement.located(By.css('.name'))),
     *           })
     *         )
     *       )
     *   );
     * ```
     *
     * #### Merging objects using `Question.fromObject`
     *
     * ```ts
     *  import { actorCalled, Question } from '@serenity-js/core'
     *  import { Send, PostRequest } from '@serenity-js/rest'
     *  import { By, Text, PageElement } from '@serenity-js/web'
     *
     *  await actorCalled('Daisy')
     *    .whoCan(CallAnApi.at('https://api.example.org'))
     *    .attemptsTo(
     *      Send.a(
     *        PostRequest.to('/products/2')
     *          .with(
     *            Question.fromObject({
     *              name: Text.of(PageElement.located(By.css('.name'))),
     *              quantity: undefined,
     *            }, {
     *              quantity: 2,
     *            })
     *          )
     *        )
     *    );
     *
     * @param source
     * @param overrides
     *
     * #### Learn more
     * - {@apilink WithAnswerableProperties}
     * - {@apilink RecursivelyAnswered}
     * - {@apilink Answerable}
     */
    static fromObject<Source_Type extends object>(source: Answerable<WithAnswerableProperties<Source_Type>>, ...overrides: Array<Answerable<Partial<WithAnswerableProperties<Source_Type>>>>): QuestionAdapter<RecursivelyAnswered<Source_Type>>;
    /**
     * Checks if the value is a {@apilink Question}.
     *
     * @param maybeQuestion
     *  The value to check
     */
    static isAQuestion<T>(maybeQuestion: unknown): maybeQuestion is Question<T>;
    protected static createAdapter<AT>(statement: Question<AT>): QuestionAdapter<Awaited<AT>>;
    private static fieldDescription;
    private static methodDescription;
    /**
     * Returns the description of the subject of this {@apilink Question}.
     */
    abstract toString(): string;
    /**
     * Changes the description of this question's subject.
     *
     * @param subject
     */
    abstract describedAs(subject: string): this;
    /**
     * Instructs the provided {@apilink Actor} to use their {@apilink Ability|abilities}
     * to answer this question.
     */
    abstract answeredBy(actor: AnswersQuestions & UsesAbilities): T;
    /**
     * Maps this question to one of a different type.
     *
     * ```ts
     * Question.about('number returned as string', actor => '42')   // returns: QuestionAdapter<string>
     *   .as(Number)                                                // returns: QuestionAdapter<number>
     * ```
     *
     * @param mapping
     */
    as<O>(mapping: (answer: Awaited<T>) => Promise<O> | O): QuestionAdapter<O>;
}
declare global {
    interface ProxyConstructor {
        new <Source_Type extends object, Target_Type extends object>(target: Source_Type, handler: ProxyHandler<Source_Type>): Target_Type;
    }
}
/**
 * Describes an object recursively wrapped in {@apilink QuestionAdapter} proxies, so that:
 * - both methods and fields of the wrapped object can be used as {@apilink Question|questions} or {@apilink Interactions|interactions}
 * - method parameters of the wrapped object will accept {@apilink Answerable|Answerable<T>}
 *
 * @group Questions
 */
export type QuestionAdapterFieldDecorator<Original_Type> = {
    [Field in keyof Omit<Original_Type, keyof QuestionStatement<Original_Type>>]: Original_Type[Field] extends (...args: infer OriginalParameters) => infer OriginalMethodResult ? (...args: {
        [P in keyof OriginalParameters]: Answerable<Awaited<OriginalParameters[P]>>;
    }) => QuestionAdapter<Awaited<OriginalMethodResult>> : Original_Type[Field] extends number | bigint | boolean | string | symbol | object ? QuestionAdapter<Awaited<Original_Type[Field]>> : any;
};
/**
 * A union type representing a proxy object returned by {@apilink Question.about}.
 *
 * {@apilink QuestionAdapter} proxies the methods and fields of the wrapped object recursively,
 * allowing them to be used as either a {@apilink Question} or an {@apilink Interaction}.
 *
 * @group Questions
 */
export type QuestionAdapter<T> = Question<Promise<T>> & Interaction & {
    isPresent(): Question<Promise<boolean>>;
} & QuestionAdapterFieldDecorator<T>;
/** @package */
declare class QuestionStatement<Answer_Type> extends Interaction implements Question<Promise<Answer_Type>>, Optional {
    private subject;
    private readonly body;
    private answer;
    constructor(subject: string, body: (actor: AnswersQuestions & UsesAbilities, ...Parameters: any[]) => Promise<Answer_Type> | Answer_Type);
    /**
     * Returns a Question that resolves to `true` if resolving the {@apilink QuestionStatement}
     * returns a value other than `null` or `undefined`, and doesn't throw errors.
     */
    isPresent(): Question<Promise<boolean>>;
    answeredBy(actor: AnswersQuestions & UsesAbilities): Promise<Answer_Type>;
    performAs(actor: UsesAbilities & AnswersQuestions): Promise<void>;
    [util.inspect.custom](depth: number, options: util.InspectOptionsStylized, inspect: typeof util.inspect): string;
    describedAs(subject: string): this;
    toString(): string;
    as<O>(mapping: (answer: Awaited<Answer_Type>) => (Promise<O> | O)): QuestionAdapter<O>;
}
export {};
//# sourceMappingURL=Question.d.ts.map