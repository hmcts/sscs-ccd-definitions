"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExecutionSuccessful = exports.ExecutionSkipped = exports.ExecutionIgnored = exports.ImplementationPending = exports.ExecutionFailedWithAssertionError = exports.ExecutionFailedWithError = exports.ExecutionCompromised = exports.ProblemIndication = exports.Outcome = void 0;
/* eslint-disable @typescript-eslint/explicit-module-boundary-types,unicorn/prefer-math-trunc */
const tiny_types_1 = require("tiny-types");
const errors_1 = require("../errors");
class Outcome extends tiny_types_1.TinyType {
    constructor(code) {
        super();
        this.code = code;
    }
    isWorseThan(another) {
        const code = (another instanceof Outcome)
            ? another.code
            : another.Code;
        return this.code < code;
    }
    toJSON() {
        return {
            code: this.code,
        };
    }
}
Outcome.fromJSON = (o) => (0, tiny_types_1.match)(o.code)
    .when(ExecutionCompromised.Code, _ => ExecutionCompromised.fromJSON(o))
    .when(ExecutionFailedWithError.Code, _ => ExecutionFailedWithError.fromJSON(o))
    .when(ExecutionFailedWithAssertionError.Code, _ => ExecutionFailedWithAssertionError.fromJSON(o))
    .when(ImplementationPending.Code, _ => ImplementationPending.fromJSON(o))
    .when(ExecutionIgnored.Code, _ => ExecutionIgnored.fromJSON(o))
    .when(ExecutionSkipped.Code, _ => ExecutionSkipped.fromJSON(o))
    .when(ExecutionSuccessful.Code, _ => ExecutionSuccessful.fromJSON(o))
    .else(_ => { throw new Error(`Outcome could not be deserialised: ${JSON.stringify(o)}`); });
exports.Outcome = Outcome;
class ProblemIndication extends Outcome {
    constructor(error, code) {
        super(code);
        this.error = error;
    }
    toJSON() {
        return {
            code: this.code,
            error: errors_1.ErrorSerialiser.serialise(this.error),
        };
    }
}
exports.ProblemIndication = ProblemIndication;
/**
 * Indicates a failure due to external events or systems that compromise the validity of the test.
 */
class ExecutionCompromised extends ProblemIndication {
    constructor(error) {
        super(error, ExecutionCompromised.Code);
    }
}
ExecutionCompromised.Code = 1 << 0;
ExecutionCompromised.fromJSON = (o) => new ExecutionCompromised(errors_1.ErrorSerialiser.deserialise(o.error));
exports.ExecutionCompromised = ExecutionCompromised;
/**
 * Indicates a failure due to an error other than recognised external system and assertion failures
 */
class ExecutionFailedWithError extends ProblemIndication {
    constructor(error) {
        super(error, ExecutionFailedWithError.Code);
    }
}
ExecutionFailedWithError.Code = 1 << 1;
ExecutionFailedWithError.fromJSON = (o) => new ExecutionFailedWithError(errors_1.ErrorSerialiser.deserialise(o.error));
exports.ExecutionFailedWithError = ExecutionFailedWithError;
/**
 * Execution of an Activity or Scene has failed due to an assertion error;
 */
class ExecutionFailedWithAssertionError extends ProblemIndication {
    constructor(error) {
        super(error, ExecutionFailedWithAssertionError.Code);
    }
}
ExecutionFailedWithAssertionError.Code = 1 << 2;
ExecutionFailedWithAssertionError.fromJSON = (o) => new ExecutionFailedWithAssertionError(errors_1.ErrorSerialiser.deserialise(o.error));
exports.ExecutionFailedWithAssertionError = ExecutionFailedWithAssertionError;
/**
 * A pending Activity is one that has been specified but not yet implemented.
 * A pending Scene is one that has at least one pending Activity.
 */
class ImplementationPending extends ProblemIndication {
    constructor(error) {
        super(error, ImplementationPending.Code);
    }
}
ImplementationPending.Code = 1 << 3;
ImplementationPending.fromJSON = (o) => new ImplementationPending(errors_1.ErrorSerialiser.deserialise(o.error));
exports.ImplementationPending = ImplementationPending;
/**
 * The result of the scenario should be ignored, most likely because it's going to be retried.
 */
class ExecutionIgnored extends ProblemIndication {
    constructor(error) {
        super(error, ExecutionIgnored.Code);
    }
}
ExecutionIgnored.Code = 1 << 4;
ExecutionIgnored.fromJSON = (o) => new ExecutionIgnored(errors_1.ErrorSerialiser.deserialise(o.error));
exports.ExecutionIgnored = ExecutionIgnored;
/**
 * The Activity was not executed because a previous one has failed.
 * A whole Scene can be marked as skipped to indicate that it is currently "work-in-progress"
 */
class ExecutionSkipped extends Outcome {
    constructor() {
        super(ExecutionSkipped.Code);
    }
}
ExecutionSkipped.Code = 1 << 5;
ExecutionSkipped.fromJSON = (o) => new ExecutionSkipped();
exports.ExecutionSkipped = ExecutionSkipped;
/**
 * Scenario or activity ran as expected.
 */
class ExecutionSuccessful extends Outcome {
    constructor() {
        super(ExecutionSuccessful.Code);
    }
}
ExecutionSuccessful.Code = 1 << 6;
ExecutionSuccessful.fromJSON = (o) => new ExecutionSuccessful();
exports.ExecutionSuccessful = ExecutionSuccessful;
//# sourceMappingURL=outcomes.js.map