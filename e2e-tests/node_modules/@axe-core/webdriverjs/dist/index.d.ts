import { WebDriver } from 'selenium-webdriver';
import { AxeResults, SerialFrameSelector, RunOptions, Spec } from 'axe-core';

interface BuilderOptions {
    noSandbox?: boolean;
    logIframeErrors?: boolean;
}
declare type CallbackFunction = (error: Error | null, results: AxeResults | null) => void;

declare class AxeBuilder {
    private driver;
    private axeSource;
    private includes;
    private excludes;
    private option;
    private config;
    private builderOptions;
    private legacyMode;
    private errorUrl;
    constructor(driver: WebDriver, axeSource?: string | null, builderOptions?: BuilderOptions);
    /**
     * Selector to include in analysis.
     * This may be called any number of times.
     */
    include(selector: SerialFrameSelector): this;
    /**
     * Selector to exclude in analysis.
     * This may be called any number of times.
     */
    exclude(selector: SerialFrameSelector): this;
    /**
     * Set options to be passed into axe-core
     */
    options(options: RunOptions): this;
    /**
     * Limit analysis to only the specified rules.
     * Cannot be used with `AxeBuilder#withTags`
     */
    withRules(rules: string | string[]): this;
    /**
     * Limit analysis to only specified tags.
     * Cannot be used with `AxeBuilder#withRules`
     */
    withTags(tags: string | string[]): this;
    /**
     * Set the list of rules to skip when running an analysis.
     */
    disableRules(rules: string | string[]): this;
    /**
     * Set configuration for `axe-core`.
     * This value is passed directly to `axe.configure()`
     */
    configure(config: Spec): this;
    /**
     * Performs an analysis and retrieves results.
     */
    analyze(callback?: CallbackFunction): Promise<AxeResults>;
    /**
     * Use frameMessenger with <same_origin_only>
     *
     * This disables use of axe.runPartial() which is called in each frame, and
     * axe.finishRun() which is called in a blank page. This uses axe.run() instead,
     * but with the restriction that cross-origin frames will not be tested.
     */
    setLegacyMode(legacyMode?: boolean): this;
    /**
     * Analyzes the page, returning a promise
     */
    private analyzePromise;
    /**
     * Use axe.run() to get results from the page
     */
    private runLegacy;
    /**
     * Get partial results from the current context and its child frames
     */
    private runPartialRecursive;
    /**
     * Use axe.finishRun() to turn partial results into actual results
     */
    private finishRun;
}

export { AxeBuilder as default };
