"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Predicate = exports.Failure = exports.Success = exports.Result = void 0;
/**
 * @access public
 */
var Result = /** @class */ (function () {
    function Result(value) {
        this.value = value;
    }
    return Result;
}());
exports.Result = Result;
/**
 * @access public
 */
var Success = /** @class */ (function (_super) {
    __extends(Success, _super);
    function Success() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Success;
}(Result));
exports.Success = Success;
/**
 * @access public
 */
var Failure = /** @class */ (function (_super) {
    __extends(Failure, _super);
    function Failure(value, description) {
        var _this = _super.call(this, value) || this;
        _this.description = description;
        return _this;
    }
    return Failure;
}(Result));
exports.Failure = Failure;
/**
 * @desc Describes a {@link Condition} that the `value` should meet.
 *
 * To define a custom predicate to be used with the {@link check} function
 * you can either extend the {@link Predicate}, or use the {@link Predicate.to} factory method.
 *
 * @example <caption>Assuming we'd like to create an isDefined() predicate:</caption>
 * ensure(`some value`, value, isDefined());
 *
 * @example <caption>We can either use the Predicate.to factory method:</caption>
 *
 * import { Predicate } from 'tiny-types';
 *
 * function isDefined<T>(): Predicate<T> {
 *     return Predicate.to(`be defined`, (value: T) =>
 *         ! (value === null || value === undefined),
 *     );
 * }
 *
 * @example <caption>or extend the Predicate itself</caption>
 *
 * import { Predicate, Result, Success, Failure } from 'tiny-types';
 *
 * function isDefined<T>() {
 *   return new IsDefined<T>();
 * }
 *
 * class IsDefined<T> extends Predicate<T> {
 *     check(value: T): Result<T> {
 *       return ! (value === null || value === undefined)
 *         ? new Success(value)
 *         : new Failure(value, `be defined`);
 *     }
 * }
 *
 * @access public
 */
var Predicate = /** @class */ (function () {
    function Predicate() {
    }
    /**
     * @desc A factory method instantiating a single-condition predicate.
     * You can use it instead of extending the {Predicate} to save some keystrokes.
     *
     * @example
     * Predicate.to(`be defined`, (value: T) => ! (value === null || value === undefined));
     *
     * @param {string} description     - The description of the condition is used by {@link check} to generate the error
     *                                   message. The description should be similar to`be defined`,
     *                                   `be less than some value` for the error message to make sense.
     * @param {Condition<V>} condition - a function that takes a value of type `V` and returns a boolean
     *                                   indicating whether or not the condition is met. For example:
     *                                   `(value: V) => !! value`
     * @returns {Predicate<V>}
     *
     * @static
     */
    Predicate.to = function (description, condition) {
        return new SingleConditionPredicate(description, condition);
    };
    return Predicate;
}());
exports.Predicate = Predicate;
/**
 * @access private
 */
var SingleConditionPredicate = /** @class */ (function (_super) {
    __extends(SingleConditionPredicate, _super);
    function SingleConditionPredicate(description, isMetBy) {
        var _this = _super.call(this) || this;
        _this.description = description;
        _this.isMetBy = isMetBy;
        return _this;
    }
    /** @override */
    SingleConditionPredicate.prototype.check = function (value) {
        return this.isMetBy(value)
            ? new Success(value)
            : new Failure(value, this.description);
    };
    return SingleConditionPredicate;
}(Predicate));
//# sourceMappingURL=Predicate.js.map